
# 1. Introducci√≥n

## **1.1 ¬øQu√© es la Programaci√≥n en Redes?**

<aside style="border: 2px solid green; padding: 10px; border-radius: 5px;"> üêõ
Es el proceso de escribir programas o procesos que permiten la comunicaci√≥n entre aplicaciones o dispositivos a trav√©s de una red.
</aside>

- En aplicaciones distribuidas, diferentes componentes se ejecutan en distintas m√°quinas.
- Suele seguir el modelo **Cliente/Servidor**:
    - **Servidor:** Proporciona un servicio.
    - **Cliente:** Solicita dicho servicio.

**Ejemplos del mundo real**

>üìã
>
>
>Bancos (cajero ‚Üí cliente) üè¶
>
>
Camareros (mesero ‚Üí cliente) üçΩÔ∏è
>
>
>Agentes de viajes (agente ‚Üí cliente) ‚úàÔ∏è

---

Tambi√©n existe el modelo **Peer-to-Peer (P2P)**, donde todos los nodos pueden actuar como cliente y servidor simult√°neamente.

---

## **1.2 Sockets y Protocolos** üîå

Un **socket** es la base de la comunicaci√≥n entre aplicaciones en red.

Un **protocolo** es un conjunto de reglas que define c√≥mo se debe intercambiar la informaci√≥n.

**Ejemplo:**

- **TCP/IP:** Es la pila de protocolos m√°s usada en Internet.
    - **TCP:** Protocolo de control de transmisi√≥n.
    - **IP:** Protocolo de Internet.

---

## **1.3La Pila de Protocolos TCP/IP** üõ†Ô∏è

Se organiza en **4 capas** de abstracci√≥n:

| **Capa**                                                      | **Descripci√≥n**                                                                                  |
| ------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| 1. <span style="color:rgb(243, 141, 73)">Enlace (Link)</span> | Operaciones cercanas al hardware. Intercambio de bits entre dispositivos f√≠sicamente conectados. |
| 2. <span style="color:rgb(243, 141, 73)">Red (Network)</span> | Comunicaci√≥n entre redes. Identifica redes de origen y destino.                                  |
| 3. <span style="color:rgb(243, 141, 73)">Transporte</span>    | Comunicaci√≥n entre procesos a trav√©s de canales espec√≠ficos.                                     |
| 4. <span style="color:rgb(243, 141, 73)">Aplicaci√≥n</span>    | Servicios para el usuario final (como HTTP, FTP).                                                |

```markdown
1.  Enlace        - Ethernet, Wi-Fi
2.  Red           - IP
3.  Transporte    - TCP, UDP
4.  Aplicaci√≥n    - HTTP, FTP, SMTP
```

---

## **1.4 Direcciones IP y Puertos**

### **IPv4**

- Formato: `xxx.xxx.xxx.xxx` (4 n√∫meros de 0 a 255).
- Ejemplo: `192.168.10.150`.
- **32 bits** de informaci√≥n: hasta **4.3 mil millones** de direcciones posibles (ya insuficientes debido al crecimiento de dispositivos IoT).

### **IPv6**

- Formato: `xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx` (hexadecimal).
- Ejemplo: `3002:0bd6:0000:0000:0000:ee00:0033:6778`.
- **128 bits**: soporta **un n√∫mero pr√°cticamente ilimitado** de direcciones.

## **Puertos**

<aside style="border: 2px solid green; padding: 10px; border-radius: 5px;"> üêõ
Los <b>puertos</b> permiten ejecutar m√∫ltiples servicios en un dispositivo:
</aside>

- Rangos (<span style="color:rgb(255, 0, 0)">Importante</span>) :

| Rango           | Descripci√≥n                                                |
| --------------- | ---------------------------------------------------------- |
| **0-1023**      | Puertos bien conocidos (e.g., 80 para HTTP, 25 para SMTP). |
| **1024-49151**  | Puertos registrados (semi-reservados).                     |
| **49152-65535** | Puertos ef√≠meros (usados por clientes).                    |


---

## **Protocolos de Transporte: TCP y UDP**

| <span style="color:rgb(0, 176, 240)">TCP</span> | <span style="color:rgb(0, 176, 240)">UDP</span> |
| ----------------------------------------------- | ----------------------------------------------- |
| Basado en conexi√≥n.                             | No basado en conexi√≥n (datagramas).             |
| Garantiza entrega de datos y en orden.          | No garantiza entrega ni orden.                  |
| M√°s confiable pero m√°s lento.                   | Menos confiable pero m√°s r√°pido.                |
| Ejemplo: Transferencia de archivos grandes.     | Ejemplo: Videollamadas o streaming en vivo.     |

- <span style="color:rgb(0, 176, 240)">TCP</span>:<span style="color:rgb(0, 176, 240)"></span> Para aplicaciones que necesitan comunicaci√≥n confiable.
- <span style="color:rgb(0, 176, 240)">UDP</span>: Para aplicaciones que necesitan rapidez (como videojuegos o llamadas VoIP).

| **Protocolo**                                   | **Fiabilidad** | **Velocidad** | **Uso t√≠pico**                   |
| ----------------------------------------------- | -------------- | ------------- | -------------------------------- |
| <span style="color:rgb(0, 176, 240)">TCP</span> | Alta           | Baja          | Transferencia de archivos üìÇ     |
| <span style="color:rgb(0, 176, 240)">UDP</span> | Baja           | Alta          | Streaming üé•, Juegos en l√≠nea üéÆ |

---

üñ•Ô∏è **Direcci√≥n IP y Puerto Ejemplo**

```yaml
IP: 192.168.1.100
Puerto: 8080
```

---

# **2. ¬øQu√© es `java.net.NetworkInterface`?**

<aside style="border: 2px solid orange; padding: 10px; border-radius: 5px;"> 
‚ôªÔ∏è Es una clase que <b>representa las interfaces de red tanto de hardware como de software.</b> Incluye informaci√≥n como:<br>
- El nombre de la interfaz.<br>
- Las direcciones IP asociadas.<br>
- Informaci√≥n adicional relacionada. 
</aside>

**Se usa especialmente en sistemas con m√∫ltiples interfaces de red** (NICs) para controlar por cu√°l de ellas se env√≠an los paquetes.

<aside style="border: 2px solid orange; padding: 10px; border-radius: 5px;">
<h4><b> ‚ôªÔ∏èinterfaz de red:</b></h4><br>
- Es el punto donde un dispositivo (computadora) se conecta a la red.<br>
- Puede ser **hardware** (como una tarjeta de red f√≠sica) o **software** (como la interfaz `loopback` para pruebas). 
- </aside>

---

## **M√©todos principales de `NetworkInterface`**

| <span style="color:rgb(255, 0, 0)">M√©todo</span> | <span style="color:rgb(255, 0, 0)">Descripci√≥n</span>                                                                      |
| ------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------- |
| `getName()`                                      | Devuelve el **nombre** de la interfaz de red.                                                                              |
| `getInetAddresses()`                             | Retorna una **enumeraci√≥n** de todas las direcciones IP asignadas a la interfaz.                                           |
| `getInterfaceAddresses()`                        | Devuelve una **lista** de todas las direcciones de interfaz (m√°s detallado que `getInetAddresses`).                        |
| `getSubInterfaces()`                             | Retorna una **enumeraci√≥n** de todas las subinterfaces (interfaces virtuales). Ejemplo: `eth0:2` es subinterfaz de `eth0`. |
| `getParent()`                                    | En caso de ser una subinterfaz, devuelve la interfaz **principal**. Si no es una subinterfaz, devuelve `null`.             |
| `getIndex()`                                     | Devuelve el **√≠ndice** asignado por el sistema a la interfaz. √ötil como alternativa al nombre para referenciarla.          |
| `getDisplayName()`                               | Devuelve un **nombre legible** de la interfaz.                                                                             |
| `getByName(String name)`                         | Encuentra la interfaz con el nombre especificado. Si no existe, devuelve `null`.                                           |
| `getByIndex(int index)`                          | Busca la interfaz seg√∫n su √≠ndice.                                                                                         |
| `getByInetAddress(InetAddress addr)`             | Encuentra la interfaz asociada a una direcci√≥n `InetAddress`.                                                              |
| `getNetworkInterfaces()`                         | Devuelve una enumeraci√≥n con **todas las interfaces** de red en el sistema.                                                |
| `isUp()`                                         | Indica si la interfaz est√° activa y funcionando.                                                                           |
| `isLoopback()`                                   | Indica si la interfaz es de tipo **loopback** (utilizada para pruebas locales).                                            |
| `isPointToPoint()`                               | Indica si la interfaz es **punto a punto**.                                                                                |
| `supportsMulticast()`                            | Indica si la interfaz **soporta multicasting**.                                                                            |
| `getHardwareAddress()`                           | Devuelve la direcci√≥n MAC de la interfaz como un array de bytes. (requieren permisos de seguridad adecuados)               |
| `getMTU()`                                       | Devuelve la **unidad m√°xima de transmisi√≥n** (MTU), que es el tama√±o m√°ximo del paquete que puede enviarse en la red.      |
| `isVirtual()`                                    | Indica si la interfaz es **virtual** (creada sobre una f√≠sica).                                                            |
| `equals(Object obj)`                             | Compara dos interfaces. Son iguales si tienen el mismo nombre y direcciones.                                               |
| `hashCode()`                                     | Devuelve el c√≥digo hash de la interfaz.                                                                                    |
| `toString()`                                     | Retorna una **descripci√≥n en texto** de la interfaz.                                                                       |

---

# **3. `java.net.InterfaceAddress`**

Esta clase **representa una direcci√≥n de interfaz de red**, que incluye:

>- Direcci√≥n IP.
>- M√°scara de subred.
>- Direcci√≥n de broadcast (en IPv4).
  > 	 - (nota) Las direcciones de **broadcast** solo aplican a IPv4, mientras que IPv6 solo maneja prefijos de red.

## **M√©todos principales de `InterfaceAddress`**

| <span style="color:rgb(255, 0, 0)">M√©todo</span> | <span style="color:rgb(255, 0, 0)">Descripci√≥n</span>                                                     |
| ------------------------------------------------ | --------------------------------------------------------------------------------------------------------- |
| `getAddress()`                                   | Devuelve la direcci√≥n IP (`InetAddress`) asociada a la interfaz.                                          |
| `getBroadcast()`                                 | Retorna la direcci√≥n de broadcast (`InetAddress`) asociada. Devuelve `null` si la direcci√≥n es IPv6.      |
| `getNetworkPrefixLength()`                       | Retorna el **largo del prefijo de red** (longitud de la m√°scara de subred).                               |
| `equals(Object obj)`                             | Compara dos objetos `InterfaceAddress` para determinar si son iguales.                                    |
| `hashCode()`                                     | Devuelve el c√≥digo hash para esta direcci√≥n de interfaz.                                                  |
| `toString()`                                     | Devuelve una **representaci√≥n en texto** de la direcci√≥n en formato: `Interface Address / Prefix Length`. |

---

### **Ejemplo b√°sico de uso**

```java
import java.net.*;
import java.util.*;

public class NetworkExample {
    public static void main(String[] args) {
        try {
            // Obtener todas las interfaces de red
            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();

            while (interfaces.hasMoreElements()) {
                NetworkInterface netInterface = interfaces.nextElement();

                // Imprimir informaci√≥n b√°sica de las distintas interfaces
                System.out.println("Nombre: " + netInterface.getName());
                System.out.println("Nombre legible: " + netInterface.getDisplayName());
                System.out.println("Est√° activa: " + netInterface.isUp());
                System.out.println("Soporta multicast: " + netInterface.supportsMulticast());
                System.out.println("MTU: " + netInterface.getMTU());
                System.out.println("Direcci√≥n MAC: " + Arrays.toString(netInterface.getHardwareAddress()));

                // Obtener direcciones asociadas a cada interfaz de red
                Enumeration<InetAddress> addresses = netInterface.getInetAddresses();
                while (addresses.hasMoreElements()) {
                    InetAddress address = addresses.nextElement();
                    System.out.println("Direcci√≥n IP: " + address.getHostAddress());
                }
                System.out.println("----------------------------------------");
            }
        } catch (SocketException e) {
            e.printStackTrace();
        }
    }
}
```

---

## üìå **Uso com√∫n:**

- Monitorizaci√≥n de red.
- Selecci√≥n de interfaz espec√≠fica en sistemas con m√∫ltiples NICs.
- Configuraci√≥n y depuraci√≥n de redes.

---

# **4. `java.net.InetAddress` en Java**

## **¬øQu√© es `InetAddress`?**

La clase `java.net.InetAddress` encapsula tanto:

- Direcciones IP (IPv4 e IPv6).
- Nombres de dominio asociados.

> Se utiliza para trabajar con direcciones IP y hostnames, permitiendo resolver nombres en direcciones y viceversa.

## **Tipos de direcciones soportadas:**

1. **Unicast:** Identifica una √∫nica interfaz.
2. **Multicast:** Identifica un conjunto de interfaces.

### **Restricci√≥n clave:**

- `InetAddress` no tiene constructores visibles. Los objetos deben crearse mediante **m√©todos f√°brica** (m√©todos est√°ticos).

---

## **M√©todos f√°brica de `InetAddress` (Est√°ticos)**

| <span style="color:rgb(255, 0, 0)"><M√©todo</span> | <span style="color:rgb(255, 0, 0)">Descripci√≥n</span>                                                           |
| ------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| `getLocalHost()`                                  | Devuelve una instancia de `InetAddress` que contiene el hostname y la direcci√≥n IP local.                       |
| `getByName(String host)`                          | Devuelve una instancia de `InetAddress` que representa el hostname o direcci√≥n IP especificada en el argumento. |
| `getAllByName(String hostName)`                   | Devuelve un array con todas las direcciones IP asociadas al hostname dado.                                      |
| `getByAddress(byte[] IPAddress)`                  | Crea y retorna un objeto `InetAddress` a partir de una direcci√≥n IP en formato de bytes.                        |
| `getByAddress(String hostName, byte[] IPAddress)` | Crea y retorna un objeto `InetAddress` basado en un hostname y una direcci√≥n IP espec√≠fica.                     |

---

### **Ejemplo pr√°ctico de uso**

```java
import java.net.InetAddress;
import java.net.UnknownHostException;

public class InetAddressExample {
    public static void main(String[] args) {
        try {
            // Obtener InetAddress del host local
            InetAddress localAddress = InetAddress.getLocalHost();
            System.out.println("Local Host: " + localAddress);

            // Obtener InetAddress de un hostname
            InetAddress googleAddress = InetAddress.getByName("www.google.com");
            System.out.println("Google Host: " + googleAddress);

            // Obtener todas las direcciones asociadas a un hostname
            InetAddress[] allGoogleAddresses = InetAddress.getAllByName("www.google.com");
            for (InetAddress address : allGoogleAddresses) {
                System.out.println("Google Address: " + address);
            }

            // Crear un InetAddress desde una direcci√≥n IP
            byte[] ipBytes = {127, 0, 0, 1}; // Direcci√≥n IP de loopback
            InetAddress loopbackAddress = InetAddress.getByAddress(ipBytes);
            System.out.println("Loopback Address: " + loopbackAddress);

            // Crear un InetAddress desde hostname y direcci√≥n IP
            byte[] customIp = {(byte) 192, (byte) 168, 0, 1};
            InetAddress customHost = InetAddress.getByAddress("MiServidor", customIp);
            System.out.println("Custom Host: " + customHost);

        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
}
```

---

## **M√©todos principales de instancia**

| <span style="color:rgb(255, 0, 0)">M√©todo</span>          | <span style="color:rgb(255, 0, 0)">Descripci√≥n</span>                                        |
| --------------------------------------------------------- | -------------------------------------------------------------------------------------------- |
| `getAddress()`                                            | Devuelve la direcci√≥n IP en forma de array de bytes.                                         |
| `getCanonicalHostName()`                                  | Devuelve el **nombre de dominio completo** asociado a esta direcci√≥n IP.                     |
| `getHostAddress()`                                        | Devuelve la direcci√≥n IP en forma de cadena (por ejemplo: `"192.168.1.1"`).                  |
| `getHostName()`                                           | Devuelve el hostname asociado a esta direcci√≥n IP.                                           |
| `isAnyLocalAddress()`                                     | Comprueba si la direcci√≥n es una direcci√≥n local no espec√≠fica (por ejemplo: `0.0.0.0`).     |
| `isLinkLocalAddress()`                                    | Comprueba si la direcci√≥n es de tipo enlace-local (como IPv6 con prefijo `FE80::`).          |
| `isLoopbackAddress()`                                     | Comprueba si la direcci√≥n es una **direcci√≥n de loopback** (como `127.0.0.1` o `::1`).       |
| `isMulticastAddress()`                                    | Comprueba si la direcci√≥n es una **direcci√≥n multicast**.                                    |
| `isSiteLocalAddress()`                                    | Comprueba si la direcci√≥n es una direcci√≥n local de sitio (como `192.168.x.x` o `10.x.x.x`). |
| `isReachable(int timeout)`                                | Prueba si la direcci√≥n es alcanzable dentro del tiempo de espera dado (en milisegundos).     |
| `isReachable(NetworkInterface net, int ttl, int timeout)` | Igual que el anterior, pero especificando la interfaz de red y el TTL (tiempo de vida).      |
| `toString()`                                              | Convierte la direcci√≥n en una representaci√≥n en texto.                                       |

Algunos m√©todos requieren ciertos permisos para ser ejecutados

---

### **Ejemplo avanzado: Probar conectividad**

```java
import java.net.InetAddress;

public class ReachabilityExample {
    public static void main(String[] args) {
        try {
            InetAddress address = InetAddress.getByName("www.google.com");

            System.out.println("Probar conectividad con: " + address);

            // Probar si es alcanzable en 5000ms
            if (address.isReachable(5000)) {
                System.out.println(address + " es alcanzable.");
            } else {
                System.out.println(address + " NO es alcanzable.");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

---

# **5. Clase `java.net.URL`**

<aside  style="border: 2px solid brown; padding: 10px; border-radius: 5px;"> ü¶•
La clase `URL` representa un Localizador Uniforme de Recursos (URL), que identifica recursos en la web (archivos, im√°genes, p√°ginas, etc.). Un URL est√° compuesto por:
</aside>

1. **Protocolo:** HTTP, HTTPS, FTP, etc.
2. **Nombre del host:** Nombre del servidor (por ejemplo: `www.google.com`) o direcci√≥n IP.
3. **N√∫mero de puerto (opcional):** Si no se especifica, se utiliza el puerto predeterminado del protocolo.
4. **Nombre del recurso:** Ruta al archivo o recurso en el servidor.

---

## **Constructores de la clase `URL` (deprecated)**

|Constructor|Descripci√≥n|
|---|---|
|`URL(String address)`|Crea un objeto URL desde una cadena con la direcci√≥n del recurso.|
|`URL(String protocol, String host, String file)`|Crea un objeto URL con el protocolo, host y archivo especificados.|
|`URL(String protocol, String host, int port, String file)`|Incluye tambi√©n el puerto del servidor.|
|`URL(URL context, String spec)`|Construye un URL bas√°ndose en otro URL como contexto.|

> ‚ö† **Nota:** Los constructores est√°n marcados como _obsoletos_. Se recomienda usar la clase `java.net.URI` para construir o analizar URLs.

---

## **M√©todos principales de `URL`**

| <span style="color:rgb(255, 0, 0)">M√©todo</span> | <span style="color:rgb(255, 0, 0)">Descripci√≥n</span>                                    |
| ------------------------------------------------ | ---------------------------------------------------------------------------------------- |
| `getProtocol()`                                  | Devuelve el protocolo del URL (por ejemplo: `"https"`).                                  |
| `getHost()`                                      | Devuelve el hostname (por ejemplo: `"www.google.com"`).                                  |
| `getPort()`                                      | Devuelve el n√∫mero de puerto especificado en el URL. Si no est√° definido, devuelve `-1`. |
| `getDefaultPort()`                               | Devuelve el puerto predeterminado asociado al protocolo.                                 |
| `getPath()`                                      | Devuelve la ruta del recurso (por ejemplo: `"/images/photo.jpg"`).                       |
| `getFile()`                                      | Similar a `getPath()`, pero incluye la consulta (`?query`).                              |
| `getQuery()`                                     | Devuelve la parte de la consulta (texto despu√©s de `?` en el URL).                       |
| `getRef()`                                       | Devuelve el fragmento del URL (texto despu√©s de `#`).                                    |

---

### **Ejemplo b√°sico con `URL`**

```java
import java.net.URL;

public class URLExample {
    public static void main(String[] args) {
        try {
            URL url = new URL("<https://en.wikipedia.org/wiki/Internet#Terminology>");
            System.out.println("Protocolo: " + url.getProtocol());
            System.out.println("Host: " + url.getHost());
            System.out.println("Puerto: " + url.getPort());
            System.out.println("Puerto por defecto: " + url.getDefaultPort());
            System.out.println("Ruta: " + url.getPath());
            System.out.println("Archivo: " + url.getFile());
            System.out.println("Consulta: " + url.getQuery());
            System.out.println("Referencia: " + url.getRef());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

---

# **6. Clase `java.net.URLConnection`**

<aside> üí≠

La clase abstracta `URLConnection` permite establecer conexiones entre aplicaciones y recursos en la web mediante un objeto `URL`. Proporciona m√©todos para leer, escribir y recuperar metadatos de la conexi√≥n.

</aside>

---

## **Subclases de `URLConnection`**

1. **`HttpURLConnection`:** Usada para conexiones HTTP o HTTPS.
    1. (Algunos metodos pueden requerir permisos espec√≠ficos)
2. **`JarURLConnection`:** Usada para acceder a recursos dentro de archivos JAR.

---

## **Pasos para usar `URLConnection`**

1. Crear un objeto `URL`.
2. Abrir la conexi√≥n con el m√©todo `openConnection()` para obtener un objeto `URLConnection`.
3. Configurar la conexi√≥n seg√∫n sea necesario.
4. Leer los campos del encabezado.
5. Leer los datos usando un `InputStream` o escribir datos usando un `OutputStream`.
6. Cerrar la conexi√≥n.

---

## **M√©todos principales de `URLConnection`**

| <span style="color:rgb(255, 0, 0)">M√©todo</span> | <span style="color:rgb(255, 0, 0)">Descripci√≥n</span>                |
| ------------------------------------------------ | -------------------------------------------------------------------- |
| `getContent()`                                   | Obtiene el contenido del recurso referenciado por el URL.            |
| `getHeaderFields()`                              | Devuelve un mapa con los campos de encabezado HTTP y sus valores.    |
| `getContentLength()`                             | Devuelve la longitud del contenido (en bytes).                       |
| `getInputStream()`                               | Devuelve un flujo de entrada para leer datos del recurso.            |
| `getOutputStream()`                              | Devuelve un flujo de salida para escribir datos al recurso.          |
| `getDate()`                                      | Devuelve la fecha de la √∫ltima modificaci√≥n del recurso.             |
| `setDoInput(boolean)`                            | Indica si se pueden recibir datos del recurso (por defecto: `true`). |
| `setDoOutput(boolean)`                           | Indica si se pueden enviar datos al recurso (por defecto: `false`).  |
| `setAllowUserInteraction()`                      | Permite la interacci√≥n del usuario.                                  |

---

### **Ejemplo b√°sico con `URLConnection`**

```java
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLConnection;

public class URLConnectionExample {
    public static void main(String[] args) {
        try {
            // Crear objeto URL
            URL url = new URI("<https://www.example.com>").toURL;

            // Abrir conexi√≥n
            URLConnection connection = url.openConnection();

            // Leer datos usando InputStream
            InputStream input = connection.getInputStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(input));

            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }

            // Cerrar flujo
            reader.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

---

# 7. Sockets

## **¬øQu√© es un Socket?**

<aside  style="border: 2px solid orange; padding: 10px; border-radius: 5px;"> üßÆ
Un <b>socket</b> es un canal de comunicaci√≥n que permite la transmisi√≥n de datos entre dos programas a trav√©s de una red üåê. Es bidireccional, es decir, tanto el cliente como el servidor pueden enviar y recibir datos.
</aside>

---

## **üîë Caracter√≠sticas principales:**

- **Protocolo:** Un **conjunto de reglas y comportamientos** que el cliente y el servidor deben seguir para establecer la comunicaci√≥n.
- **Puerto:** Es el **punto de entrada en el host** donde se establece el socket. Por ejemplo:
    - Puerto est√°ndar para HTTP: `80`
    - Representado como un n√∫mero entero.
- **Flujos de entrada y salida:** Se utilizan para **enviar y recibir datos** entre cliente y servidor.

---

## **Proceso en el Servidor üñ•Ô∏è**

El servidor:

1. **Crea un `ServerSocket`** y lo asocia a un puerto.
    
    ```java
    ServerSocket server = new ServerSocket(10001, 5);
    ```
    
    - **Primer argumento:** Puerto en el que estar√° disponible el servicio.
    - **Segundo argumento:** N√∫mero m√°ximo de clientes en espera antes de rechazar conexiones.
2. **Espera solicitudes de conexi√≥n** usando el m√©todo `accept()`.
    
    - Este m√©todo es **bloqueante** (espera hasta que un cliente se conecte).
3. **Comunicaci√≥n bidireccional:** Una vez conectado, se crean flujos de entrada y salida para enviar y recibir mensajes.
    
4. **Cierra la conexi√≥n:** Al finalizar la comunicaci√≥n, el servidor llama a `close()`.
    

---

### **Ejemplo del lado del servidor:**

```java
ServerSocket server;
Socket socket;
try {
    server = new ServerSocket(10001, 5); // Crea un servidor en el puerto 10001
    socket = server.accept(); // Espera a que un cliente se conecte
    // Comunicaci√≥n con el cliente...
    socket.close(); // Cierra la conexi√≥n
} catch (IOException e) {
    e.printStackTrace();
}
```

---

## **Proceso en el Cliente üíª**

El cliente:

1. **Abre un socket** para conectarse al servidor.
    
    ```java
    connection = new Socket("localhost", 10001);
    ```
    
    - **Primer argumento**: direcci√≥n del servidor (URL o IP) y el puerto.
    - **Segundo argumento**: puerto en el que se establece la comunicaci√≥n.
2. **Comunicaci√≥n bidireccional:** Crea flujos de entrada y salida para comunicarse con el servidor.
    
3. **Cierra la conexi√≥n:** Una vez terminado el intercambio de datos, el cliente llama a `close()`.
    

---

### **Ejemplo del lado del cliente:**

```java
Socket connection;
try {
    connection = new Socket("localhost", 10001); // Conexi√≥n al servidor
    // Comunicaci√≥n bidireccional con el servidor...
    connection.close(); // Cierra la conexi√≥n
} catch (IOException e) {
    e.printStackTrace();
}localhost
```

---

## **M√©todos comunes para la comunicaci√≥n üì®**

1. **`writeToSocket(Socket sock, String str)`**
    
    Env√≠a datos desde el cliente o servidor.
    
    ```java
    public void writeToSocket(Socket sock, String str) throws IOException {
        OutputStream oStream = sock.getOutputStream();
        for (int i = 0; i < str.length(); i++) {
            oStream.write(str.charAt(i)); // Env√≠a cada car√°cter
        }
    }
    ```
    
2. **`readFromSocket(Socket sock)`**
    
    Recibe datos desde el cliente o servidor.
    
    ```java
    public String readFromSocket(Socket sock) throws IOException {
        InputStream iStream = sock.getInputStream();
        StringBuilder str = new StringBuilder();
        char c;
        while ((c = (char) iStream.read()) != '\\n') { // Lee hasta encontrar un salto de l√≠nea
            str.append(c);
        }
        return str.toString();
    }
    ```
    

---

### **Ejemplo pr√°ctico: Servidor simple de fecha y hora ‚è∞**

- **C√≥digo del servidor:**

```java
import java.io.IOException;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.util.Date;

public class DateServer {
    public static void main(String[] args) throws IOException {
        try (var listener = new ServerSocket(57777)) { // Puerto 57777
            System.out.println("Servidor de fecha en ejecuci√≥n...");
            while (true) {
                try (var socket = listener.accept()) {
                    var out = new PrintWriter(socket.getOutputStream(), true);
                    out.println(new Date().toString()); // Env√≠a la fecha y hora al cliente
                }
            }
        }
    }
}
```

- **C√≥digo del cliente:**

```java
import java.io.IOException;
import java.net.Socket;
import java.util.Scanner;

public class DateClient {
    public static void main(String[] args) throws IOException {
        if (args.length != 1) {
            System.err.println("Proporciona la IP del servidor como argumento");
            return;
        }
        try (var socket = new Socket(args[0], 57777)) {
            var in = new Scanner(socket.getInputStream());
            System.out.println("Respuesta del servidor: " + in.nextLine()); // Muestra la fecha
        }
    }
}
```

---

### **Resumen de los pasos üìù**

| <span style="color:rgb(146, 208, 80)">Servidor</span> | <span style="color:rgb(146, 208, 80)">Cliente</span> |
| ----------------------------------------------------- | ---------------------------------------------------- |
| 1. Crear un `ServerSocket`.                           | 1. Crear un `Socket` para conectarse.                |
| 2. Usar `accept()` para esperar una conexi√≥n.         | 2. Comunicarse con el servidor.                      |
| 3. Comunicaci√≥n bidireccional.                        | 3. Cerrar la conexi√≥n con `close()`.                 |
| 4. Cerrar el socket con `close()`.                    |                                                      |

---

# **8. Ejemplo de Servidor Multihilo Sencillo**

**(Simple Threaded Server)**

Este servidor recibe l√≠neas de texto de un cliente y les responde convirti√©ndolas a **may√∫sculas**. Adem√°s, es capaz de manejar m√∫ltiples clientes **concurrientemente** mediante el uso de **hilos (threads)**. Cada vez que un cliente se conecta, el servidor crea un hilo dedicado a ese cliente para procesar y responder a sus mensajes. Este servidor **es eficiente** porque puede atender a varios clientes a la vez sin bloquear el servicio.

---

### **C√≥digo del Servidor Multihilo:**

```java
import java.io.IOException;
import java.net.ServerSocket;

public class CapitalizeMultiServer {
    private ServerSocket serverSocket;

    public static void main(String[] args) {
        CapitalizeMultiServer server = new CapitalizeMultiServer();
        server.begin(55555);  // El servidor escucha en el puerto 55555
    }

    public void begin(int port) {
        try {
            serverSocket = new ServerSocket(port);
            System.out.println("Server listening...");
            while (true) {
                // Espera la conexi√≥n de un cliente y maneja la solicitud en un nuevo hilo
                new Thread(new CapitalizeClientHandler(serverSocket.accept())).start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            stop();
        }
    }

    public void stop() {
        try {
            serverSocket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

1. **`serverSocket.accept()`**: El servidor espera y bloquea la ejecuci√≥n hasta que un cliente se conecta.
2. **`new Thread(...)`**: Cada vez que un cliente se conecta, se crea un nuevo hilo que ejecuta la clase `CapitalizeClientHandler` para gestionar la comunicaci√≥n con ese cliente.

---

### **Clase `CapitalizeClientHandler` - Manejador de Clientes:**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;

public class CapitalizeClientHandler implements Runnable {
    private Socket clientSocket;
    private PrintWriter out;
    private BufferedReader in;

    public CapitalizeClientHandler(Socket socket) {
        this.clientSocket = socket;
    }

    public void run() {
        try {
            out = new PrintWriter(clientSocket.getOutputStream(), true);
            in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                if (".".equals(inputLine)) {  // Si el cliente manda un punto (.), terminar
                    out.println("bye");
                    break;
                }
                out.println(inputLine.toUpperCase());  // Convertir el texto a may√∫sculas
            }
            in.close();
            out.close();
            clientSocket.close();
        } catch (IOException e) {
            System.out.println(e.getMessage());
        }
    }
}
```

- El **manejador de clientes** recibe un `Socket` cuando un cliente se conecta.
- Lee las l√≠neas enviadas por el cliente, las convierte a **may√∫sculas** y las devuelve.
- Si el cliente env√≠a un **"."**, el servidor responde con **"bye"** y cierra la conexi√≥n.

---

### **C√≥digo del Cliente:**

El cliente env√≠a l√≠neas de texto y recibe las respuestas en may√∫sculas del servidor.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;

public class CapitalizeClient {
    private Socket clientSocket;
    private PrintWriter out;
    private BufferedReader in;

    public static void main(String[] args) throws IOException {
        if (args.length != 1) {
            System.err.println("Pass the server IP as the sole command line argument");
            return;
        }
        CapitalizeClient capitalizeClient = new CapitalizeClient();
        capitalizeClient.startConnection(args[0], 55555);  // Conexi√≥n al servidor en el puerto 55555
        capitalizeClient.communicate();
        capitalizeClient.stopConnection();
    }

    public void communicate() throws IOException {
        System.out.println("Enter lines of text. Finish with '.'");
        Scanner scanner = new Scanner(System.in);
        String inputLine;
        String cap;
        while (scanner.hasNextLine()) {
            inputLine = scanner.nextLine();
            cap = this.sendMessage(inputLine);  // Enviar el mensaje al servidor
            System.out.println(cap);  // Mostrar respuesta
            if (cap.equals("bye")) {
                break;  // Si recibe "bye", terminar
            }
        }
    }

    public void startConnection(String ip, int port) {
        try {
            clientSocket = new Socket(ip, port);  // Conectar al servidor
            out = new PrintWriter(clientSocket.getOutputStream(), true);
            in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public String sendMessage(String msg) {
        try {
            out.println(msg);  // Enviar mensaje al servidor
            return in.readLine();  // Leer la respuesta del servidor
        } catch (Exception e) {
            return null;
        }
    }

    public void stopConnection() {
        try {
            in.close();
            out.close();
            clientSocket.close();  // Cerrar la conexi√≥n
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### **Resumen:**

- <span style="color:rgb(146, 208, 80)">Servidor</span>:
    - Escucha en el puerto `55555` y acepta m√∫ltiples conexiones.
    - Por cada conexi√≥n, crea un nuevo hilo para manejar al cliente.
    - El hilo recibe texto del cliente, lo convierte a may√∫sculas y lo env√≠a de vuelta.
- <span style="color:rgb(146, 208, 80)">Cliente</span>:
    - Se conecta al servidor y env√≠a l√≠neas de texto.
    - Recibe la respuesta en may√∫sculas del servidor.
    - Si el servidor responde con **"bye"**, el cliente termina la conexi√≥n.

---

# **9. DataInputStream and DataOutputStream in Java**

`DataInputStream` y `DataOutputStream` permiten leer y escribir tipos de datos primitivos (como `byte`, `short`, `int`, `long`, `float`, `double`, `boolean`, `char`) as√≠ como cadenas de texto (`String`) en un archivo binario.

### **M√©todos de `DataInputStream`:**

- **`readByte()`**: Lee un byte.
- **`readShort()`**: Lee un short.
- **`readInt()`**: Lee un int.
- **`readLong()`**: Lee un long.
- **`readFloat()`**: Lee un float.
- **`readDouble()`**: Lee un double.
- **`readChar()`**: Lee un char.
- **`readBoolean()`**: Lee un boolean.
- **`readUTF()`**: Lee un `String` en formato UTF.
- **`readLine()`**: Lee una l√≠nea de texto.

### **M√©todos de `DataOutputStream`:**

- **`writeByte(byte b)`**: Escribe un byte.
- **`writeShort(short s)`**: Escribe un short.
- **`writeInt(int i)`**: Escribe un int.
- **`writeLong(long l)`**: Escribe un long.
- **`writeFloat(float f)`**: Escribe un float.
- **`writeDouble(double d)`**: Escribe un double.
- **`writeChar(char ch)`**: Escribe un char.
- **`writeBoolean(boolean b)`**: Escribe un boolean.
- **`writeUTF(String s)`**: Escribe un `String` en formato UTF.
- **`writeBytes(String s)`**: Escribe un `String` como bytes.

### **ObjectInputStream and ObjectOutputStream in Java**

**Serializaci√≥n** es el proceso de convertir un objeto en un formato que se pueda almacenar, transmitir o reconstruir m√°s tarde. Para lograr la serializaci√≥n en Java, se utilizan las clases `ObjectOutputStream` y `ObjectInputStream`. Adem√°s, la clase debe implementar la interfaz `Serializable`.

### **Ejemplo de Servidor:**

```java
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class PersonServer {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        int numeroPuerto = 60000;
        ServerSocket server = new ServerSocket(numeroPuerto);
        System.out.println("Waiting for the client...");
        Socket client = server.accept();

				// the output stream is prepared for objects
        ObjectOutputStream outObject = new ObjectOutputStream(client.getOutputStream());
        Person per = new Person("Teresa", 20);
        outObject.writeObject(per);
        System.out.println("Send: " + per.getName() + "*" + per.getAge());
				
				// getting a stream for reading object
        ObjectInputStream inObject = new ObjectInputStream(client.getInputStream());
        Person person = (Person) inObject.readObject();
        System.out.println("Receive: " + person.getName() + "*" + person.getAge());

        outObject.close();
        inObject.close();
        client.close();
        server.close();
    }
}
```

### **Ejemplo de Cliente:**

```java
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;

public class PersonClient {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        String host = "localhost";
        int port = 60000;

        System.out.println("Client started...");
        Socket client = new Socket(host, port);
				
				//input stream for objects
        ObjectInputStream objIn = new ObjectInputStream(client.getInputStream());
        Person person = (Person) objIn.readObject();
        System.out.println("Receive: " + person.getName() + "*" + person.getAge());

        person.setName("Teresa Rivas");
        person.setAge(22);
				
				//output stream for object
        ObjectOutputStream outPerson = new ObjectOutputStream(client.getOutputStream());
        outPerson.writeObject(person);
        System.out.println("Send: " + person.getName() + "*" + person.getAge());

        objIn.close();
        outPerson.close();
        client.close();
    }
}
```

### **Clase `Person`:**

```java
import java.io.Serializable;

public class Person implements Serializable {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Person() { }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

---

# **10. UDP - User Datagram Protocol (Sockets)**

<aside  style="border: 2px solid yellow; padding: 10px; border-radius: 5px;"> üî•
<b>UDP (User Datagram Protocol)</b> es un protocolo de comunicaci√≥n alternativo al m√°s utilizado <b>TCP (Transmission Control Protocol)</b>. A diferencia de TCP, UDP es un protocolo <b>sin conexi√≥n (connectionless)</b>, lo que significa que los paquetes de datos se env√≠an directamente sin necesidad de establecer una conexi√≥n formal entre el cliente y el servidor.
</aside>

## **Caracter√≠sticas de UDP:**

- <span style="color:rgb(255, 255, 0)">Sin conexi√≥n</span>: No requiere una sesi√≥n previa entre el cliente y el servidor antes de la transmisi√≥n de datos.
- <span style="color:rgb(255, 255, 0)">Encabezado m√°s peque√±o</span>: Los paquetes UDP contienen menos informaci√≥n en sus encabezados en comparaci√≥n con TCP, lo que reduce la sobrecarga.
- <span style="color:rgb(255, 255, 0)">Mayor velocidad</span>: No hay mecanismos de retransmisi√≥n, correcci√≥n de errores ni confirmaciones de entrega, lo que permite una comunicaci√≥n m√°s r√°pida.
- <span style="color:rgb(255, 255, 0)">Ideal para aplicaciones en tiempo real</span>: Se utiliza en escenarios donde la velocidad es m√°s importante que la fiabilidad, como en juegos en l√≠nea, transmisi√≥n de video y llamadas VoIP.

## **Funcionamiento de UDP**

A diferencia de TCP, que establece una conexi√≥n antes de transmitir datos, UDP **env√≠a paquetes sin esperar una respuesta del receptor**. Esto lo convierte en una opci√≥n ideal para aplicaciones que pueden tolerar la p√©rdida ocasional de datos, pero que requieren baja latencia.

En una red basada en UDP:

1. El cliente env√≠a datos al servidor sin verificar si el servidor est√° listo para recibirlos.
2. El servidor escucha pasivamente y responde cuando recibe un paquete.
3. No hay garant√≠a de que los paquetes lleguen en orden o sin p√©rdidas.

### **Proceso de comunicaci√≥n UDP**

- **Cliente UDP**

Un cliente UDP sigue los siguientes pasos para enviar datos a un servidor:

1. Crear una instancia de **DatagramSocket**.
2. Construir un **DatagramPacket** con los datos y la direcci√≥n del servidor.
3. Enviar los datos con el m√©todo `send()`.
4. Esperar una posible respuesta con `receive()`.
5. Cerrar el socket con `close()`.

A diferencia de TCP, **DatagramSocket no necesita una direcci√≥n de destino fija**. Se puede enviar un datagrama a cualquier servidor en cualquier momento.

- **Servidor UDP**

Un servidor UDP debe seguir estos pasos para recibir y responder a los clientes:

1. Crear una instancia de **DatagramSocket**, especificando el puerto local y, opcionalmente, la direcci√≥n local.
2. Escuchar los paquetes entrantes con `receive()`.
3. Extraer la direcci√≥n del cliente para enviarle una respuesta.
4. Comunicarse enviando y recibiendo paquetes con `send()` y `receive()`.
5. Cerrar el socket con `close()`.

El servidor UDP, al ser **sin conexi√≥n**, **no establece un canal de comunicaci√≥n permanente con el cliente**, sino que espera recibir datagramas y responde seg√∫n sea necesario.

### **Ejemplo de Cliente UDP:**

```java
import java.io.IOException;
import java.net.*;
import java.util.logging.Level;
import java.util.logging.Logger;

public class ClientUDP {
	 public static void main(String[] args) {

		 //server port
		 final int SERVER_PORT = 50000;
		 //buffer to store the messages
		 byte[] buffer = new byte[1024];
		 
		 try {
 
			 //We get the location of the server
			 InetAddress serverAddress = InetAddress.getByName("localhost");
			 
			 //Creates the UDP socket
			 DatagramSocket socketUDP = new DatagramSocket();
			 
			 String message = "Hello World from the client!";
			 
			 //We convert the message to bytes
			 buffer = message.getBytes();
			 
			 //We create the datagram
			 DatagramPacket question = new DatagramPacket(buffer, buffer.length,serverAddress, SERVER_PORT);
			 
			 //We send the datagram
			 System.out.println("Sending the datagram");
			 socketUDP.send(question);
			 
			 //Preparing the packet for the answer
			 DatagramPacket response = new DatagramPacket(buffer,buffer.length);
			 
			 //Receiving the answer
			 socketUDP.receive(response);
			 System.out.println("Receiving the response");
			 
			 //Taking data and showing it
			 message = new
			 String(response.getData(),0,response.getLength(),"UTF-8");
			 System.out.println(message);
			 
			 //Closing socket
			 socketUDP.close();
			 
		} catch (SocketException ex) {
			Logger.getLogger(ClientUDP.class.getName()).log(Level.SEVERE, null,ex);
		} catch (UnknownHostException ex) {
			Logger.getLogger(ClientUDP.class.getName()).log(Level.SEVERE, null,ex);
		} catch (IOException ex) {
			Logger.getLogger(ClientUDP.class.getName()).log(Level.SEVERE, null,ex);
		}
	 }
}
```

### **Ejemplo de Servidor UDP:**

```java
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.util.logging.Level;
import java.util.logging.Logger;

public class ServerUDP {
 public static void main(String[] args) {
 final int PORT = 50000;
 byte[] buffer = new byte[1024];
 try {
	 System.out.println("UDP server started");
	 
	 //Creation of socket
	 DatagramSocket socketUDP = new DatagramSocket(PORT);
	 
	 //It will always respond to requests
	 while (true) {
		 //We prepare the response
		 DatagramPacket request = new DatagramPacket(buffer,buffer.length);
		 
		 //We receive the datagram
		 socketUDP.receive(request);
		 System.out.println("Client information received");
		 
		 //We convert the received data and show the message
		 String message = new
		 String(request.getData(),0,request.getLength(),"UTF-8");
		 System.out.println(message);
		
		 //We get the port and the source address
		 int clientPort = request.getPort();
		 InetAddress address = request.getAddress();
		 message = "Hello World from the server!";
		 buffer = message.getBytes();
		 
		 //We create the datagram
		 DatagramPacket answer = new DatagramPacket(buffer,buffer.length, address, clientPort);
		
		 //We send the information
		 System.out.println("Sending information to the client");
		 socketUDP.send(answer);
	 }
	 } catch (SocketException ex) {
		 Logger.getLogger(ServerUDP.class.getName()).log(Level.SEVERE, null,ex);
	 } catch (IOException ex) {
		 Logger.getLogger(ServerUDP.class.getName()).log(Level.SEVERE, null,ex);
		}
	 }
 }
```

---

# **11. SSL en Java**

SSL (Secure Sockets Layer) permite una conexi√≥n segura entre dos partes, normalmente un cliente y un servidor. Su prop√≥sito es garantizar la seguridad de la comunicaci√≥n a trav√©s de tres principios clave:

- **Cifrado**: Protege las transmisiones de datos entre las partes.
- **Autenticaci√≥n**: Asegura que el servidor al que nos conectamos es el servidor correcto.
- **Integridad de datos**: Garantiza que los datos entregados son los mismos que fueron solicitados.

SSL es un protocolo com√∫nmente utilizado para cifrar las comunicaciones cliente-servidor, especialmente en el caso de HTTPS.

## Tipos de Cifrado

- **Cifrado sim√©trico**: Usa la misma clave para cifrar y descifrar los datos, es r√°pido y eficiente.

![[Pasted image 20250214085738.png]]

- **Cifrado asim√©trico**: Utiliza un par de claves (p√∫blica y privada), una para cifrar y otra para descifrar los datos. Este tipo de cifrado se usa en protocolos como SSL/TLS para establecer conexiones seguras.

![[Pasted image 20250214085747.png]]

## API JSSE (Java Secure Socket Extension)

La **API JSSE** permite el intercambio seguro de datos entre clientes y servidores mediante protocolos como HTTP, Telnet, o FTP sobre TCP/IP. Las clases principales son:

- **SSLSocket**: Representa un socket seguro en el cliente.
    
    ```java
    SSLSocketFactory sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();
    SSLSocket SSLClient = (SSLSocket) sslSocketFactory.createSocket(host, port);
    ```
    
- **SSLServerSocket**: Representa un socket seguro en el servidor.
    
    ```java
    SSLServerSocketFactory sslServerSocketFactory = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
    SSLServerSocket SSLserver = (SSLServerSocket) sslServerSocketFactory.createServerSocket(port);
    ```
    

## Uso de `keytool`

<aside style="border: 2px solid gray; padding: 10px; border-radius: 5px;"> ‚öô
El <b>keytool</b> es una herramienta de Java utilizada para gestionar claves y certificados en un almac√©n de claves (keystore). Para crear un par de claves p√∫blica/privada, se puede usar el siguiente comando:
</aside>

 **1. Generar un par de claves p√∫blica/privada**

```bash
keytool -genkey -keyalg RSA -alias server -keystore ServerKeys.jks -storepass 12345678
```

- Explicaci√≥n:
    - `keytool`: Es la herramienta que estamos utilizando.
    - `genkey`: Indica que vamos a generar un par de claves p√∫blica y privada.
    - `keyalg RSA`: Especifica el algoritmo de cifrado que se usar√° para las claves (en este caso, RSA).
    - `alias server`: Define un alias para identificar este par de claves dentro del keystore. Este alias se usar√° m√°s adelante para referirse a este par.
    - `keystore ServerKeys.jks`: Especifica el nombre del archivo de keystore donde se almacenar√° la clave (aqu√≠ llamado `ServerKeys.jks`).
    - `storepass 12345678`: Es la contrase√±a para proteger el keystore.

Resultado: Se genera un archivo `ServerKeys.jks` que contiene el par de claves p√∫blica y privada asociado al alias `server`.

---

 **2. Exportar el certificado p√∫blico**

```bash
keytool -exportcert -alias server -file server.cer -keystore ServerKeys.jks
```

- Explicaci√≥n:
    
    - `exportcert`: Indica que vamos a exportar el certificado asociado al alias especificado.
    - `alias server`: Identifica el alias de la clave cuya parte p√∫blica queremos exportar.
    - `file server.cer`: Especifica el nombre del archivo donde se guardar√° el certificado p√∫blico (en este caso, `server.cer`).
    - `keystore ServerKeys.jks`: Indica el keystore del que se tomar√° la clave.
    
    Resultado: Se genera un archivo llamado `server.cer` que contiene el certificado p√∫blico asociado al alias `server`.
    

---

 **3. Importar el certificado p√∫blico a otro keystore**

```bash
keytool -importcert -trustcacerts -alias server -file server.cer -keystore ClientKeys.jks -storepass 87654321
```

- Explicaci√≥n:
    
    - `importcert`: Indica que vamos a importar un certificado en un keystore.
    - `trustcacerts`: Marca el certificado como de confianza. Esto es especialmente √∫til si el certificado viene de una autoridad certificadora (CA).
    - `alias server`: Define un alias para identificar este certificado en el nuevo keystore.
    - `file server.cer`: Especifica el archivo que contiene el certificado a importar (en este caso, `server.cer`).
    - `keystore ClientKeys.jks`: Especifica el archivo de keystore donde se almacenar√° el certificado (en este caso, `ClientKeys.jks`).
    - `storepass 87654321`: Es la contrase√±a para proteger este keystore.
    
    Resultado: El certificado p√∫blico exportado (`server.cer`) se importa al keystore `ClientKeys.jks` bajo el alias `server`.
    

## Ejemplo de Servidor SSL en Java

En el servidor, se configura un `SSLServerSocket` para aceptar conexiones seguras:

```java
package marcos.psp.prueba1;

import javax.net.ssl.SSLServerSocket;
import javax.net.ssl.SSLServerSocketFactory;
import javax.net.ssl.SSLSocket;
import java.io.*;

public class SSLServer {
    public static void main(String[] args) throws IOException {
        SSLSocket clientSocket = null;
        PrintWriter out=null;
        BufferedReader in=null;

        //Properties can be specified by code
        System.setProperty("javax.net.ssl.keyStore", "ServerKeys.jks");
        System.setProperty("javax.net.ssl.keyStorePassword", "12345678");
        
        //Initialisation of the SSL ServerSocket
        int port = 60000;
        SSLServerSocketFactory sslServerSocketFactory = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
        SSLServerSocket SSLserver = (SSLServerSocket) sslServerSocketFactory.createServerSocket(port);
        
        for (int i = 1; i < 5; i++) {
            System.out.println("Waiting for the client " + i);
            //A client connection is expected with accept
            clientSocket = (SSLSocket) SSLserver.accept();
            out =new PrintWriter(clientSocket.getOutputStream(), true);
            in =new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
            
            //Message received from client
            System.out.println("Receiving from the client: " + i + " \\n\\t" + in.readLine());
            
            //The Server responds with a greeting
            out.println("Greetings to the client from the server");
        }
        //Closing streams and sockets
        in.close();
        out.close();
        clientSocket.close();
        SSLserver.close();
    }
}

```

## Ejemplo de Cliente SSL en Java

En el cliente, se configura un `SSLSocket` para conectar de manera segura al servidor:

```java
package marcos.psp.prueba1;

import javax.net.ssl.*;
import java.io.*;
import java.math.BigInteger;
import java.security.cert.X509Certificate;

public class SSLClient {
    public static void main(String[] args) throws IOException {
        SSLSocket SSLClient = null;
        PrintWriter out=null;
        System.setProperty("javax.net.ssl.trustStore", "ClientKeys.jks");
        System.setProperty("javax.net.ssl.trustStorePassword", "87654321");
        
        //SSL ServerSocket Initialisation
        int port = 60000;
        String host = "localhost";
        System.out.println("Client program started....");

        SSLSocketFactory sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefaut();

        SSLClient = (SSLSocket) sslSocketFactory.createSocket(host, port);
        showSSLSessionInformation(SSLClient);

        out =new PrintWriter(SSLClient.getOutputStream(), true);
        BufferedReader in =new BufferedReader(new InputStreamReader(SSLClient.getInputStream()));
        
        //sending a greeting to the server
        out.println("Greetings to the SERVER from the CLIENT");
        
        //The server responds with a message
        System.out.println("Receiving from the SERVER: \\n\\t" + in.readLine());
        
        //Closing streams and sockets
        in.close();
        out.close();
        SSLClient.close();
    }
    public static void showSSLSessionInformation(SSLSocket client) throws SSLPeerUnverifiedException {

        //Example of SSL session information
        SSLSession session = ((SSLSocket) client).getSession();
        System.out.println("Host: " + session.getPeerHost());
        System.out.println("Cipher: " + session.getCipherSuite());
        System.out.println("Protocol: " + session.getProtocol());
        System.out.println("IDentifier:" + new BigInteger(session.getId()));
        System.out.println("Creation of the session: " + session.getCreationTime());
        X509Certificate certificate = (X509Certificate) session.getPeerCertificates()[0];
        System.out.println("Owner: " + certificate.getSubjectDN());
        System.out.println("Algorithm: " + certificate.getSigAlgName());
        System.out.println("Type: " + certificate.getType());
        System.out.println("Sender: " + certificate.getIssuerDN());
        System.out.println("Serial Number: " + certificate.getSerialNumber());
    }
}

```

### Usando OpenSSL

**OpenSSL** es una herramienta de c√≥digo abierto que tambi√©n se usa para establecer conexiones seguras. Para conectarse a un servidor SSL, podemos usar el siguiente comando:

```bash
openssl s_client -connect localhost:60000
```

Este comando nos permite verificar las propiedades y el diagn√≥stico de la conexi√≥n SSL.