# 1. Introducci√≥n a consultas JPA

### Especificaci√≥n de JPA para consultas
 <aside style="border: 2px solid yellow; padding: 10px; border-radius: 5px;"> 
	Las <b>consultas JPA</b> son aquellas que se realizan sobre las <b>entidades</b> de la base de datos.
</aside>

 Pueden hacerse de varias formas:
### a. Lenguajes de consulta

#### 1. Consultas JPQL
_Jakarta Persistence Query Language_ es un lenguaje de consulta independiente de la base de datos, orientado a objetos, que opera sobre el modelo de entidades (l√≥gico o f√≠sico).

- **Caracter√≠sticas:**
    - Se realizan sobre las **entidades** y no directamente sobre las tablas.
- **Ejemplo:**
    ```java
	TypedQuery<Empleado> q = em.createQuery("SELECT e FROM Empleado e WHERE e.nome = :nome", Empleado.class);
	q.setParameter("nome", "Otto");
	List<Empleado> resultado = q.getResultList();
	```
#### 2. Consultas nativas SQL

Se realizan directamente en la base de datos utilizando el lenguaje SQL.

- **Ejemplo:**
    ```java
	Query q = em.createNativeQuery("SELECT * FROM EMPLEADO WHERE NOME = ?1", Empleado.class);
	q.setParameter(1, "Otto");
	List<Empleado> resultado = q.getResultList();
	```
#### 3. API Criteria
Es una API que permite construir consultas de forma program√°tica, utilizando objetos Java en lugar de cadenas de consulta.

- **Ejemplo:**
    ```java
    CriteriaBuilder cb = em.getCriteriaBuilder();
    
	CriteriaQuery<Empleado> q = cb.createQuery(Empleado.class);
	
	Root<Empleado> c = q.from(Empleado.class);
	
	q.select(c)
    .where(cb.equal(c.get("nome"), "Otto"));
    
	List<Empleado> resultado = em.createQuery(q).getResultList();

	```
---

## 1.1. M√©todos de EntityManager para crear consultas

Los m√©todos del **EntityManager** que se utilizan para crear consultas son:

| <span style="color:rgb(255, 0, 0)">M√©todo</span>                          | <span style="color:rgb(255, 0, 0)">Descripci√≥n</span>                                                                                                          |
| ------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Query createQuery(String qlString)`                                      | Crea una instancia de `Query` para ejecutar una consulta JPQL.                                                                                                 |
| `<T> TypedQuery<T> createQuery(String qlString, Class<T> claseResultado)` | Crea una instancia de `TypedQuery` para una consulta JPQL tipada. El resultado del SELECT debe poder asignarse al tipo `claseResultado`.                       |
| `Query createQuery(CriteriaUpdate updateQuery)`                           | Crea una instancia de `Query` para ejecutar una consulta de actualizaci√≥n basada en Criteria.                                                                  |
| `Query createQuery(CriteriaDelete deleteQuery)`                           | Crea una instancia de `Query` para ejecutar una consulta de eliminaci√≥n basada en Criteria.                                                                    |
| `<T> TypedQuery<T> createQuery(CriteriaQuery<T> criteriaQuery)`           | Crea una instancia de `TypedQuery` para ejecutar una consulta basada en Criteria.                                                                              |
| `Query createNativeQuery(String sqlString)`                               | Crea una instancia de `Query` para ejecutar una consulta SQL nativa. Si la consulta no es de borrado/actualizaci√≥n, devuelve un array de objetos (`Object[]`). |
| `Query createNativeQuery(String sqlString, Class claseResultado)`         | Crea una instancia de `Query` para ejecutar una consulta SQL nativa, indicando el tipo de datos devuelto.                                                      |
| `Query createNativeQuery(String sqlString, String resultSetMapping)`      | Crea una instancia de `Query` para ejecutar una consulta SQL nativa, utilizando un mapeo de conjunto de resultados.                                            |

> üìí**Nota adicional:**  
> Tambi√©n se pueden definir consultas con nombre (_NamedQuery_) mediante la anotaci√≥n `@NamedQuery` en la entidad.
> 
> **Ejemplo:**
>```java
>@Entity
>@NamedQuery(name="Empleado.findByNome", query="SELECT e FROM Empleado e WHERE e.nome = :nome")
>public class Empleado {
>```
---

## 1.2. M√©todos de Query

La interfaz **Query** proporciona m√©todos para la ejecuci√≥n y gesti√≥n de las consultas. Estos son algunos de los principales:

| <span style="color:rgb(255, 0, 0)">M√©todo</span>                          | <span style="color:rgb(255, 0, 0)">Descripci√≥n</span>                                                                                                                                                      |
| ------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `int executeUpdate()`                                                     | Ejecuta una consulta de actualizaci√≥n o eliminaci√≥n y devuelve el n√∫mero de entidades afectadas.                                                                                                           |
| `List getResultList()`                                                    | Ejecuta la consulta y devuelve una lista de resultados. La lista no es tipada.                                                                                                                             |
| `default Stream getResultStream()`                                        | Ejecuta la consulta y devuelve un `Stream` no tipado de resultados. Por defecto, delega a `getResultList().stream()`, aunque proveedores como Hibernate pueden sobrescribirlo para mejorar el rendimiento. |
| `Object getSingleResult()`                                                | Ejecuta la consulta y devuelve un √∫nico resultado. Si la consulta devuelve m√°s de uno, lanza una excepci√≥n `NonUniqueResultException`.                                                                     |
| `Query setFirstResult(int startPosition)`                                 | Establece la posici√≥n del primer resultado a recuperar, √∫til para paginaci√≥n.                                                                                                                              |
| `Query setMaxResults(int maxResult)`                                      | Establece el n√∫mero m√°ximo de resultados a recuperar, tambi√©n para paginaci√≥n.                                                                                                                             |
| `int getFirstResult()`                                                    | Devuelve la posici√≥n del primer resultado. Retorna 0 si no se ha usado `setFirstResult()`.                                                                                                                 |
| `Query setParameter(int position, Object value)`                          | Asigna un valor a un par√°metro de la consulta por posici√≥n.                                                                                                                                                |
| `Query setParameter(String name, Object value)`                           | Asigna un valor a un par√°metro de la consulta por nombre.                                                                                                                                                  |
| `Query setParameter(int position, Date value, TemporalType temporalType)` | Asigna un valor a un par√°metro de tipo temporal (`java.util.Date`) a la consulta.                                                                                                                          |

> <span style="color:rgb(34, 70, 155)"><b>Consultas Tipadas y Excepciones</b></span>:  
> La interfaz `jakarta.persistence.TypedQuery<X>` sobrescribe los m√©todos `getResultList()`, `getResultStream()` y `getSingleResult()` para devolver resultados del tipo `X`.  
> El m√©todo `getSingleResult()` lanza una excepci√≥n de tipo `NoResultException` si no se encuentra ning√∫n resultado.

---

## Ejemplo completo de consulta JPA

A continuaci√≥n se muestra un ejemplo completo de una aplicaci√≥n que interact√∫a con la consola para ejecutar consultas JPA:
```java
import java.util.Scanner;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Persistence;
import java.util.List;

public class JPAQuery {

    public static Scanner SCAN = new Scanner(System.in);

    public static void main(String[] args) {

        EntityManager em;
        if (args.length != 1) {
            // em = JPAUtil.getEntityManager();
            em = Persistence.createEntityManagerFactory("bibliotecaH2").createEntityManager();
        } else {
            // em = JPAUtil.getEntityManager(args[0]);
            em = Persistence.createEntityManagerFactory(args[0]).createEntityManager();
        }

        System.out.println("Escribe la orden \"salir;\" para salir.");
        boolean salir = false;

        while (!salir) {

            System.out.print("Jakarta Persistence QL> ");
            StringBuilder sb = new StringBuilder();
            do {
                sb.append(" ").append(SCAN.nextLine().trim());
            } while (!sb.toString().endsWith(";"));

            String consulta = sb.substring(0, sb.length() - 1);
            if (!consulta.equalsIgnoreCase("salir")) {
                if (consulta.isEmpty()) {
                    continue;
                }
                try {
                    if ("select".equalsIgnoreCase(consulta.trim().substring(0, 6))) {
                        // Consulta JPQL: Se ejecuta y se obtienen resultados tipados.
                        // TypedQuery<?> q = em.createQuery(consulta, Object.class);
                        List<?> resultado = em.createQuery(consulta).getResultList(); // Las wildcard permiten devolver cualquier tipo de objeto
                        if (!resultado.isEmpty()) {
                            int count = 0;
                            for (Object o : resultado) {
                                System.out.print(++count + " ");
                                mostrarResultados(o);
                            }
                        } else {
                            System.out.println("0 resultados de la consulta");
                        }
                    } else {
                        int i = em.createQuery(consulta).executeUpdate();
                        System.out.println(i + " elementos modificados");
                    }
                } catch (Exception e) {
                    System.out.println("Error al procesar la consulta: " + e.getMessage());
                }
            } else {
                salir = true;
            }
        }
    }

    private static void mostrarResultados(Object resultado) {
        if (resultado == null) {
            System.out.print("NULL");
        } else if (resultado instanceof Object[] fila) {
            System.out.print("[");
            for (Object o : fila) {
                mostrarResultados(o);
            }
            System.out.print("]");
        } else if (resultado instanceof Long || resultado instanceof Double || resultado instanceof String) {
            System.out.print(resultado.getClass().getName() + ": " + resultado);
        } else {
            // ReflectionToStringBuilder es una clase de Apache Commons Lang que
            // permite la conversi√≥n de objetos a cadenas de texto.
            // System.out.print(ReflectionToStringBuilder.toString(resultado, ToStringStyle.SHORT_PREFIX_STYLE));
            System.out.print(resultado);
        }
        System.out.println();
    }
}

```


> **Descripci√≥n del Ejemplo:**
> 
> - **Inicializaci√≥n:** Se crea un `EntityManager` a partir de una factor√≠a de persistencia.
> - **Entrada de Usuario:** El programa permite ingresar consultas en la consola, terminadas con un punto y coma (`;`).
> - **Ejecuci√≥n:**
>     - Si la consulta inicia con `"select"`, se asume que es una consulta de selecci√≥n JPQL y se ejecuta para obtener resultados, que se muestran uno a uno.
>     - Si no es de selecci√≥n, se ejecuta como consulta de actualizaci√≥n/eliminaci√≥n, mostrando el n√∫mero de elementos modificados.
> - **Visualizaci√≥n:** El m√©todo `mostrarResultados` se encarga de imprimir los resultados, gestionando tanto valores simples como arreglos de objetos.

---

## üó∫Ô∏è Diagrama de Flujo de la Consulta JPA
```mermaid
flowchart TD
    A[Inicio: Espera de consulta] --> B{¬øLa entrada termina con ;?}
    B -->|No| A
    B -->|S√≠| C[Extraer consulta sin el ; final]
    C --> D{¬øConsulta es 'salir'?}
    D -->|S√≠| E[Finalizar programa]
    D -->|No| F{¬øConsulta inicia con 'select'?}
    F -->|S√≠| G[Ejecutar consulta JPQL y obtener resultados]
    F -->|No| H[Ejecutar consulta de actualizaci√≥n/eliminaci√≥n]
    G --> I[Mostrar resultados en consola]
    H --> J[Mostrar n√∫mero de elementos modificados]
    I --> A
    J --> A
```
# 2. Jakarta Persistence Query Language (JPQL)
## 2.1. Historia de JPQL

**Origen y Evoluci√≥n:**

1. **EJB QL:**  
    El origen de JPQL es el _Enterprise JavaBeans Query Language (EJB QL)_, introducido en la especificaci√≥n EJB 2.0.
    
    - Permit√≠a escribir m√©todos portables de b√∫squeda y selecci√≥n para beans de entidad gestionados por contenedores.
    - Se basaba en un peque√±o subconjunto de SQL y permit√≠a navegar a trav√©s de las relaciones de entidad para seleccionar datos y filtrar resultados.
    - _Limitaciones:_
        - Restring√≠a los resultados a una √∫nica entidad o a un campo persistente de una entidad.
        - Las uniones internas entre entidades se realizaban con una notaci√≥n extra√±a y la versi√≥n inicial ni siquiera admit√≠a la ordenaci√≥n.
2. **EJB QL 2.1:**
    - Se ajust√≥ EJB QL, a√±adiendo soporte para la ordenaci√≥n y funciones agregadas b√°sicas.
    - Sin embargo, la limitaci√≥n de un √∫nico tipo de resultado obstaculizaba el uso de agregados (no hab√≠a equivalente a GROUP BY y HAVING de SQL).
3. **Jakarta Persistence QL:**  
    Extiende significativamente EJB QL, eliminando muchas de las debilidades de las versiones anteriores, manteniendo compatibilidad hacia atr√°s y a√±adiendo caracter√≠sticas como:
    
    - **Tipos de resultados:**
        - Pueden devolver un √∫nico objeto, un campo persistente, una lista de entidades o una lista de campos persistentes.
    - **Funciones agregadas con ordenaci√≥n y agrupaci√≥n:**
        - Soporte para GROUP BY y HAVING.
    - **Sintaxis de uni√≥n natural:**
        - Soporte para inner joins y outer joins (LEFT JOIN, RIGHT JOIN).
    - **Expresiones condicionales con subconsultas:**
        - Uso de EXISTS, ALL, ANY y SOME.
    - **Consultas de actualizaci√≥n y eliminaci√≥n:**
        - Soporta UPDATE y DELETE para cambios masivos de datos.
    - **Proyecci√≥n en clases no persistentes:**
        - Uso de la cl√°usula `SELECT NEW` para construir DTOs (Data Transfer Objects).

---

## 2.2. Sintaxis de JPQL

La sintaxis de JPQL es similar a la de SQL, pero opera sobre **entidades** y sus atributos, en lugar de sobre tablas y columnas.

>- **Definici√≥n:**
  > 	 - Las consultas JPQL se definen como cadenas de texto y se pueden incrustar en el c√≥digo Java.
   > 	- Se pueden ejecutar din√°micamente en tiempo de ejecuci√≥n, permitiendo adaptar la consulta a condiciones cambiantes.

### 2.2.1. Consultas SELECT

Las consultas **SELECT** se usan para recuperar datos. La sintaxis b√°sica es:
```sql
SELECT [DISTINCT] select_expression
FROM identification_variable_declaration
[WHERE conditional_expression]
[GROUP BY grouping_expression]
[HAVING conditional_expression]
[ORDER BY ordering_expression [ASC | DESC]]

```
- **Cl√°usulas de una consulta SELECT:**
    - <span style="color:rgb(192, 0, 0)"><b>SELECT</b></span>: Determina el tipo de objetos o valores a seleccionar.
    - <span style="color:rgb(192, 0, 0)"><b>FROM</b></span>: Indica el dominio o entidad sobre la que se aplica la consulta.
    - <span style="color:rgb(192, 0, 0)"><b>WHERE</b></span> **(opcional)**: Restringe los resultados seg√∫n una condici√≥n.
    - <span style="color:rgb(192, 0, 0)"><b>GROUP BY</b></span> **(opcional)**: Agrega los resultados en grupos.
    - <span style="color:rgb(192, 0, 0)"><b>HAVING</b></span> **(opcional)**: Filtra sobre grupos agregados.
    - <span style="color:rgb(192, 0, 0)"><b>ORDER BY</b></span> **(opcional)**: Ordena los resultados.

> **BNF:**  
> `select_statement ::= select_clause from_clause [where_clause] [groupby_clause] [having_clause] [orderby_clause]`  
> (La cl√°usula SELECT y FROM son obligatorias; las dem√°s son opcionales).

- <u>**Ejemplo simple:**</u>  
    Seleccionar todas las instancias de la entidad _Empleado_:
    ```sql
	SELECT e
	FROM Empleado e
	```
    La consulta devuelve una lista de cero o m√°s instancias de _Empleado_.
    
- <u>**Navegaci√≥n a trav√©s de relaciones:**</u>  
    Se utiliza el operador punto (.) para acceder a atributos o relaciones:
	```sql
	SELECT e.nombre
	FROM Empleado e
	```
    Aqu√≠ se recupera el campo persistente `nombre` (de tipo simple o incrustable) de cada _Empleado_.
    
- <u>**Selecci√≥n de una entidad relacionada:** </u> 
    Por ejemplo, si _Empleado_ tiene una relaci√≥n muchos a uno con _Departamento_:
	```sql
	SELECT e.departamento
	FROM Empleado e
	```
	
    La consulta devuelve la entidad _Departamento_ asociada a cada _Empleado_.

---

### 2.2.2. Filtrado de resultados

Se utiliza la cl√°usula **WHERE** para filtrar los resultados. Las operaciones disponibles en SQL que se pueden usar incluyen:

- **Operadores b√°sicos de comparaci√≥n:**  
    `=`, `>`, `<`, `>=`, `<=`, `<>`
    
- **Expresiones:**  
    `BETWEEN`, `LIKE`, `IN`, `IS NULL`, `IS NOT NULL`
    
- **Funciones de cadena:**  
    `CONCAT`, `SUBSTRING`, `TRIM`, `LOWER`, `UPPER`, `LENGTH`, `LOCATE`
    
- **Funciones aritm√©ticas:**  
    `ABS`, `CEILING`, `EXP`, `FLOOR`, `LN`, `MOD`, `POWER`, `ROUND`, `SIGN`, `SQRT`, `SIZE`, `INDEX`
    
- **Funciones de fecha:**  
    `CURRENT_DATE`, `CURRENT_TIME`, `CURRENT_TIMESTAMP`, `EXTRACT`, `...`
    
- **Funciones de agregado:**  
    `AVG`, `COUNT`, `MAX`, `MIN`, `SUM`
    

**Ejemplo 1:**  
Filtrar empleados con salario mayor a 1000:
```sql
SELECT e
FROM Empleado e
WHERE e.salario > 1000
```
**Ejemplo 2:**  
Filtrar empleados del departamento "Ventas" y ciudad "Santiago":
```sql
SELECT e
FROM Empleado e
WHERE e.departamento.nombre = 'Ventas' 
  AND e.direccion.ciudad = 'Santiago'
```
---

### 2.2.3. Proyecci√≥n de resultados

Cuando se desea recuperar solo ciertos campos de una entidad, se usa la cl√°usula **SELECT** para proyectar los resultados.

- **Ejemplo:**  
    Recuperar solo el nombre y el salario de los empleados:
    ```sql
	 SELECT e.nombre, e.salario
	FROM Empleado e
	WHERE e.salario > 1000	
	```
    - La consulta devuelve una lista de objetos `Object[]` donde cada array contiene dos elementos: el nombre y el salario.

#### Referencias de constructores NEW

Para consultas de _solo lectura_ se puede usar la proyecci√≥n con constructores:

- **Ejemplo:**
    ```sql
	 SELECT new com.pepinho.ad.jpa.AutorDTO(a.idAutor, a.nome, a.apelidos)
	FROM Autor a
	```
    - Esto crea una instancia de `AutorDTO` para cada registro, evitando el gasto de manejo de entidades administradas.
- **Resultados distintos:**  
    Utilizando `DISTINCT` para eliminar duplicados:
    ```sql
	SELECT DISTINCT e.departamento
	FROM Empleado e
	```
#### Expresiones condicionales con CASE
JPQL admite expresiones CASE, √∫tiles para clasificar o etiquetar resultados:

- **Ejemplo 1:**
    ```sql
	SELECT e.nombre, CASE WHEN e.salario > 2000 THEN 'Alto' ELSE 'Bajo' END
	FROM Empleado e
	```
- **Ejemplo 2 (CASE simple):**
    ```sql
	SELECT e.nombre, 
	       CASE e.salario
	           WHEN 1000 THEN 'Bajo'
	           WHEN 2000 THEN 'Medio'
	           ELSE 'Alto'
	       END
	FROM Empleado e
	```
- **Ejemplo en UPDATE:**
    ```sql
	UPDATE Empleado e
	SET e.salario =
	    CASE WHEN e.clasificacion = 1 THEN e.salario * 1.1
	         WHEN e.clasificacion = 2 THEN e.salario * 1.05
	         ELSE e.salario * 1.01
	    END
	```
- **Ejemplo con TYPE:**
    ```sql
	SELECT e.nombre,
	       CASE TYPE(e) 
	           WHEN Desarrollador THEN 'Desarrollador'
	           WHEN Administrador THEN 'Administrador'
	           WHEN Profesor THEN 'Profesor'
	           ELSE 'Empleado'
	       END
	FROM Empleado e
	WHERE e.departamento.nombre = 'Sistemas'	
	```
- **Ejemplo combinado:**
    ```sql
	SELECT e.nombre,
	       f.nombre,
	       CONCAT(
	         CASE WHEN f.kmAnuales > 50000 THEN 'Platinum '
	              WHEN f.kmAnuales > 25000 THEN 'Dorada '
	              WHEN f.kmAnuales > 10000 THEN 'Plateada '
	              ELSE ''
	         END,
	         ' Frecuencia'
	       )
	FROM Empleado e JOIN e.planDeViaje f	
	```
---

### 2.2.4. Joins entre entidades

<aside style="border: 2px solid blue; padding: 10px; border-radius: 5px;"> 
üëÅÔ∏è Las consultas JPQL no pueden devolver directamente colecciones; el resultado debe ser un objeto √∫nico (entidad o campo). Para acceder a elementos de una colecci√≥n o navegar entre asociaciones se utilizan <b>joins</b>.
</aside>

-  **Sin join expl√≠cito (Forma antigua):**
```sql
SELECT p.numero
FROM Empleado e, Telefono t
WHERE e = t.empleado 
  AND e.departamento.nombre = 'Desarrollo' 
  AND t.tipo = 'M√≥vil'
```
-  **Con join (usando JOIN en la cl√°usula FROM):**
```sql
SELECT p.numero
FROM Empleado e JOIN e.telefonos p
WHERE e.departamento.nombre = 'Desarrollo'
  AND p.tipo = 'M√≥vil'
```

> **Ventajas del operador JOIN:**
> 
> - Se expresa en t√©rminos de la asociaci√≥n definida en la entidad.
> - El motor de consultas genera autom√°ticamente los criterios de uni√≥n necesarios.

#### Tipos de Joins:

- **Inner Join (Join Relacionado):**  
    Devuelve solo las filas con correspondencia en ambas entidades.
    
    **Sintaxis:**
    ```sql
	[INNER] JOIN join_association_path_expression [AS] identification_variable [join_condition]	
	```
    
    **Ejemplo:**
    ```sql
	SELECT a, p FROM Autor a JOIN a.libros p
	```
    Tambi√©n:
    ```sql
	SELECT c FROM Cliente c INNER JOIN c.pedidos p WHERE c.estado = 1
	```
    Equivalente usando `IN`:
    ```sql
	SELECT OBJECT(c) FROM Cliente c, IN(c.pedidos) p WHERE c.estado = 1
	```
- **Left Outer Join:**  
    Permite incluir en el resultado entidades que pueden no tener correspondencia (valores nulos en la uni√≥n).
    
    **Sintaxis:**
    ```sql
	LEFT [OUTER] JOIN join_association_path_expression [AS] identification_variable [join_condition]
	```
    **Ejemplo:**
    ```sql
	SELECT s.nombre, COUNT(p)
	FROM Proveedor s LEFT JOIN s.productos p
	GROUP BY s.nombre	
	```
    Equivalente a SQL:
    ```sql
	SELECT s.nombre, COUNT(p.id)
	FROM Proveedor s LEFT JOIN Producto p
	       ON s.idProveedor = p.idProducto
	GROUP BY s.nombre	
	```
    Tambi√©n se puede especificar una condici√≥n adicional en la uni√≥n:
    ```sql
	SELECT s.nombre, COUNT(p)
	FROM Proveedor s LEFT JOIN s.productos p ON p.estado = 'stock'
	GROUP BY s.nombre
	```
- **Fetch Joins:**  
    Se utilizan para obtener asociaciones o colecciones de forma conjunta con la entidad principal (efecto secundario de la consulta).
    
    **Sintaxis:**
    ```sql
	[LEFT [OUTER] | INNER] JOIN FETCH join_association_path_expression	
	```
    **Restricciones:**
    
    - No se puede asignar una variable de identificaci√≥n para la parte derecha del FETCH JOIN.
    - Los objetos relacionados no se devuelven expl√≠citamente en el resultado.
    
    **Ejemplo:**
    ```sql
	SELECT d
	FROM Departamento d LEFT JOIN FETCH d.empleados
	WHERE d.numeroDepartamento = 1
	```
    > üí° _Nota:_ Si el departamento 1 tiene cinco empleados, la consulta devuelve cinco referencias al mismo departamento, pero los empleados se cargan de forma proactiva.
    

---

### 2.2.5. Consultas Agregadas

La sintaxis para consultas agregadas en JPQL es muy similar a SQL. Se admiten cinco funciones agregadas:

- <span style="color:rgb(192, 0, 0)"><b>AVG</b></span>
- <span style="color:rgb(192, 0, 0)"><b>COUNT</b></span>
- <span style="color:rgb(192, 0, 0)"><b>MIN</b></span>
- <span style="color:rgb(192, 0, 0)"><b>MAX</b></span>
- <span style="color:rgb(192, 0, 0)"><b>SUM</b></span>

Los resultados se pueden agrupar con **GROUP BY** y filtrar con **HAVING**.

**Ejemplo:**
```sql
SELECT d, COUNT(e), MAX(e.salario), AVG(e.salario)
FROM Departamento d JOIN d.empleados e
GROUP BY d
HAVING COUNT(e) >= 5
```

---

### 2.2.6. Par√°metros en las consultas

JPQL admite dos formas para la vinculaci√≥n de par√°metros:

- **Vinculaci√≥n posicional:**  
    Se indican en la consulta mediante un signo de interrogaci√≥n seguido del n√∫mero de par√°metro (similar a JDBC).
    
    **Ejemplo:**
    ```sql
	SELECT e
	FROM Empleado e
	WHERE e.departamento = ?1 AND
	      e.salario > ?2	
	```
- **Par√°metros con nombre:**  
    Se indican con dos puntos seguidos del nombre del par√°metro.
    
    **Ejemplo:**
    ```sql
	SELECT e
	FROM Empleado e
	WHERE e.departamento = ?1 AND
	      e.salario > ?2
	```

---
## Visualizaci√≥n y Resumen

### Tabla Resumen de Caracter√≠sticas de JPQL

| Caracter√≠stica                                                        | Descripci√≥n                                                                                                                    |
| --------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| <span style="color:rgb(255, 0, 0)"><b>Lenguaje de consulta</b></span> | Basado en SQL, pero opera sobre entidades y sus atributos en lugar de tablas y columnas.                                       |
| <span style="color:rgb(255, 0, 0)"><b>Compatibilidad</span>           | Extiende EJB QL, manteniendo compatibilidad hacia atr√°s y superando sus limitaciones.                                          |
| <span style="color:rgb(255, 0, 0)"><b>Tipos de consulta</span>        | - JPQL (consultas orientadas a objetos)  <br>- Consultas nativas SQL  <br>- API Criteria (consultas program√°ticas)             |
| <span style="color:rgb(255, 0, 0)"><b>Funciones y cl√°usulas</span>    | Soporta funciones agregadas, cl√°usulas GROUP BY, HAVING, expresiones condicionales (CASE), y proyecciones con constructor NEW. |
| <span style="color:rgb(255, 0, 0)"><b>Joins</span>                    | Permite inner joins, left/right outer joins y fetch joins para cargar asociaciones de forma proactiva.                         |
| <span style="color:rgb(255, 0, 0)"><b>Par√°metros</span>               | Soporta par√°metros posicionales y con nombre para mayor flexibilidad y seguridad en la construcci√≥n de consultas.              |

### Diagrama de Flujo de una Consulta SELECT con Joins y Agregados
```mermaid
flowchart TD
    A[Inicio: Definir consulta SELECT] --> B[Especificar cl√°usula FROM con entidad principal]
    B --> C{Opcional: ¬øIncluir JOIN?}
    C -->|S√≠| D[Especificar tipo: INNER, LEFT OUTER, FETCH]
    C -->|No| E[Continuar sin JOIN]
    D --> F[Agregar cl√°usula WHERE para filtrar]
    E --> F
    F --> G{Opcional: ¬øAgrupar con GROUP BY?}
    G -->|S√≠| H[Agregar GROUP BY]
    G -->|No| I[Saltar agrupaci√≥n]
    H --> J{Opcional: ¬øFiltrar grupos con HAVING?}
    J -->|S√≠| K[Agregar HAVING]
    J -->|No| L[Saltar filtro de grupos]
    I --> M{Opcional: ¬øOrdenar con ORDER BY?}
    K --> M
    L --> M
    M -->|S√≠| N[A√±adir ORDER BY]
    M -->|No| O[Saltar ordenaci√≥n]
    N --> P[Ejecutar consulta y obtener resultados]
    O --> P
```
