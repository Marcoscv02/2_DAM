<aside style="border: 2px solid yellow; padding: 10px; border-radius: 5px;"> 
Los objetos embebidos permiten extraer parte del estado de una entidad en clases reutilizables, sin que estos tengan identidad propia. Se almacenan en la misma tabla que la entidad que los contiene y <b>no se consideran relaciones</b> entre entidades.
</aside>

---

# 1. Objetos embebidos: `@Embeddable`

### üìë**Definici√≥n:**

Un¬†**objeto embebido**¬†es un objeto que¬†**no tiene identidad propia**¬†y que¬†**es¬†parte de una entidad**.

### üåÄ**Uso en Java:**

- Sed utilizan para modelar datos complejos
- Se modelan como clases Java normales y se anotan con `@**Embeddable**`.
- **Integraci√≥n en una entidad:**
    - Se declara como atributo en la entidad.
    - Se anota dicho atributo con `@Embedded`.

### ‚úÖ**Ventajas:**

- **Reutilizaci√≥n:** Por ejemplo, una clase `Direccion` puede utilizarse en distintas entidades (como `Empleado` y `Compa√±ia`).
- **Organizaci√≥n del modelo:** Permite agrupar atributos relacionados de forma l√≥gica.

### üó£Ô∏è**Ejemplo:**

```java
@Embeddable
@Access(AccessType.FIELD)
public class Direccion {
    private String calle;
    private String ciudad;
    private String provincia;

    @Column(name="codigoPostal")
    private String codigo;

  // Constructores, getters y setters
}
```

![[Pasted image 20250212173004.png|375]]

```java
@Entity
public class Empleado {
    @Id
    private long idEmpleado;

    private String nombre;
    private long salario;

    @Embedded
    private Direccion direccion;

  // Constructores, getters y setters
}
```

![[Pasted image 20250212173025.png|153]]

> Nota: Al persistir una instancia de Empleado, los atributos de Direccion se gestionan como si fueran columnas de la tabla Empleado.

<aside style="border: 2px solid red; padding: 10px; border-radius: 5px;"> 
üö® <br>
Es una¬†<b>decisi√≥n de dise√±o</b>¬†el uso de objetos embebidos.¬†<b>Si se precisa crear relaciones con ellos o desde ellos, no los uses</b>.<br>
Los objetos embebidos¬†<b>no est√°n destinados a ser entidades</b>¬†y tan pronto como comiences a tratarlos como entidades, probablemente deber√≠as convertirlos en entidades de primera clase si el modelo de datos lo permite.<br>
<b>No es port√°til definir objetos embebidos como parte de jerarqu√≠as de herencia</b>. Una vez que comienzan a heredarse entre s√≠, la complejidad de su incorporaci√≥n aumenta y la relaci√≥n costo-beneficio disminuye.
</aside>

---

# 2. Sustituci√≥n de atributos embebidos: `@AttributeOverride`

Cuando la **misma clase embebida** se utiliza en diferentes entidades, es posible que se requiera que las columnas tengan nombres distintos en cada tabla. Para ello se utiliza la anotaci√≥n `@AttributeOverride`.

### ‚öì**Uso:**

Se coloca sobre el atributo embebido en la entidad y se indica:

- **name:** Nombre del atributo de la clase embebida.
- **column:** Nueva asignaci√≥n de columna mediante una anotaci√≥n `@Column`.

### üëæ**Ejemplo en entidad `Compania`:**

```java
@Entity
public class Compania {
    @Id
    private String name;

    @Embedded
    @AttributeOverride(name = "provincia", column = @Column(name = "prov"))
    @AttributeOverride(name = "codigo", column = @Column(name = "codPostal"))
    private Direccion direccion;

    // Constructores, getters y setters
}
```

![[Pasted image 20250212173304.png]]

> Observaci√≥n:
> 
> Aunque en la clase `Direccion` el atributo se llame `provincia` y `codigo` (para el c√≥digo postal), en la tabla de `Compania` se almacenar√°n en las columnas `prov` y `codPostal`, respectivamente.

---

## 2.1. Sustituci√≥n de m√∫ltiples atributos embebidos: `@AttributeOverrides`

Si se necesita sobrescribir **m√°s de un atributo** del objeto embebido, se puede usar la anotaci√≥n contenedora `@AttributeOverrides` para agrupar varias `@AttributeOverride`.

### üåµ**Ejemplo:**

```java
@Entity
public class Compania {
    @Id
    private String name;

    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name = "provincia", column = @Column(name = "prov")),
        @AttributeOverride(name = "codigo", column = @Column(name = "codPostal"))
    })
    private Direccion direccion;

    // Constructores, getters y setters
}
```

> Nota:
> 
> Dado que la anotaci√≥n `@AttributeOverride` se puede repetir, no es obligatorio el uso de `@AttributeOverrides` a menos que se prefiera agruparlas para mayor claridad.

---

# 3. ManyToMany usando una clave compuesta

<aside style="border: 2px solid rgb(0, 32, 96); padding: 10px; border-radius: 5px;"> 
üôãüèΩ‚Äç‚ôÇÔ∏è Una¬†clave primaria compuesta, tambi√©n llamada¬†clave compuesta, es una combinaci√≥n de dos o m√°s columnas para formar una clave primaria para una tabla.
</aside>

- En JPA, tenemos¬†**dos opciones para definir las claves compuestas: ¬†`@IdClass`¬†y¬†`@EmbeddedId`**.
- Para definir las claves primarias compuestas, debemos seguir algunas reglas:
    - La clase de¬†**clave primaria compuesta¬†debe ser p√∫blica**.
    - Debe tener un¬†**constructor sin argumentos**.
    - Debe¬†**definir los¬†m√©todos¬†`equals()`¬†y¬†`hashCode()`**.
    - **Debe ser¬†`Serializable`**.

---

## 3.1. Modelando Atributos de Relaci√≥n

- **Escenario:**
    
    Un estudiante puede inscribirse en varios cursos y, adem√°s, **calificar** cada curso. La calificaci√≥n es un atributo de la relaci√≥n y no de la entidad `Estudiante` o `Curso` por s√≠ solas.
    
- **Diagrama l√≥gico:**
    
    ```lua
    Estudiante
        idEstudiante
            |
            | (relacion con atributo 'calificacion')
            |
    CalificacionCurso
        calificacion (atributo de la relaci√≥n)
            |
            |
        idCurso  <---- Curso
    ```
    

![[Pasted image 20250213091444.png|151]]

![[Pasted image 20250213091454.png|550]]

- **Observaci√≥n:**
    
    Debido a que la relaci√≥n tiene su propio atributo (`calificacion`), se debe modelar mediante una entidad que represente la tabla de uni√≥n.
    

---

## 3.2. Creando una Clave Compuesta en JPA: `@Embeddable`

>Para representar la **clave primaria compuesta** de la entidad intermedia se crea una clase que cumpla los siguientes requisitos:
>
>- Es **p√∫blica**.
>- Tiene un **constructor sin argumentos**.
>- Implementa `equals()` y `hashCode()`.
>- Es **Serializable**.

### üßã**Ejemplo:** Clase `ClaveCalificacionCurso`

```java
@Embeddable
public class ClaveCalificacionCurso implements Serializable {

    @Column(name = "idEstudiante")
    private Long idEstudiante;

    @Column(name = "idCurso")
    private Long idCurso;

    // Constructor sin argumentos
    public ClaveCalificacionCurso() {}

    // Constructor completo
    public ClaveCalificacionCurso(Long idEstudiante, Long idCurso) {
        this.idEstudiante = idEstudiante;
        this.idCurso = idCurso;
    }

    // Getters y setters

    // Implementaci√≥n de equals() y hashCode()
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ClaveCalificacionCurso that = (ClaveCalificacionCurso) o;
        return Objects.equals(idEstudiante, that.idEstudiante) &&
               Objects.equals(idCurso, that.idCurso);
    }

    @Override
    public int hashCode() {
        return Objects.hash(idEstudiante, idCurso);
    }
}
```

---

## 3.3. Utilizando una Clave Compuesta en JPA: `@EmbeddedId`

La entidad que representa la tabla de uni√≥n utilizar√° la clase compuesta como su clave primaria.

- **Ejemplo:** Entidad `CalificacionCurso`
    
    ```java
    @Entity
    public class CalificacionCurso {
    
        @EmbeddedId
        private ClaveCalificacionCurso id;
    
        @ManyToOne
        @MapsId("idEstudiante") // Vincula esta parte de la clave con el atributo 'estudiante'
        @JoinColumn(name = "idEstudiante")
        private Estudiante estudiante;
    
        @ManyToOne
        @MapsId("idCurso") // Vincula esta parte de la clave con el atributo 'curso'
        @JoinColumn(name = "idCurso")
        private Curso curso;
    
        private int calificacion;
    
        // Constructores, getters y setters
    }
    ```
    
- **Relaciones inversas en `Estudiante` y `Curso`:**
    
    ```java
    public class Estudiante {
        // ...
        @OneToMany(mappedBy = "estudiante")
        private Set<CalificacionCurso> calificaciones;
        // ...
    }
    ```
    
    ```java
    public class Curso {
        // ...
        @OneToMany(mappedBy = "curso")
        private Set<CalificacionCurso> calificaciones;
        // ...
    }
    ```
    

<aside style="border: 2px solid yellow; padding: 10px; border-radius: 5px;"> 
 üí°<span style="color:rgb(255, 192, 0)">Nota:</span><br>
 Con esta estrategia <b>se transforman las relaciones muchos a muchos en dos relaciones de muchos a uno</b>, permitiendo adjuntar atributos (como la calificaci√≥n) a la relaci√≥n.
</aside>

---

## 3.4. Caracter√≠sticas Adicionales

- **La modelaci√≥n mediante una entidad intermedia (con clave compuesta) facilita la extensi√≥n del modelo:** Por ejemplo, se podr√≠an agregar m√°s atributos o incluso relacionar la calificaci√≥n con otros elementos (como un profesor en el caso de evaluar un curso impartido por diferentes docentes).
- La implementaci√≥n con `@EmbeddedId` permite tener una referencia √∫nica a la clave compuesta, mientras que la alternativa con `@IdClass` requiere definir los campos tanto en la clase clave como en la entidad.

---

## 3.5. La anotaci√≥n `@IdClass`

Otra forma de definir una clave compuesta es mediante `@IdClass`. En este caso:

- Se define una clase (por ejemplo, `IdCuenta`) que contenga los campos de la clave.
- La entidad se anota con `@IdClass(IdCuenta.class)` y se definen los campos de clave con `@Id`.

### **Ejemplo:**

```java
public class IdCuenta implements Serializable {
    private String numeroCuenta;
    private String tipoCuenta;

    // Constructor por defecto, constructor completo, equals() y hashCode()
}
```

```java
@Entity
@IdClass(IdCuenta.class)
public class Cuenta {

    @Id
    private String numeroCuenta;

    @Id
    private String tipoCuenta;

    // Otros atributos, getters y setters
}
```

<aside style="border: 2px solid red; padding: 10px; border-radius: 5px;"> 
üö®<b>Punto importante:</b><br>
 Con `@IdClass` se deben declarar los campos de la clave <b>tanto en la clase clave como en la entidad.</b>
</aside>

---

## 3.6. La anotaci√≥n `@EmbeddedId`

Con `@EmbeddedId` se define la clave compuesta en una clase anotada con `@Embeddable` y se **inyecta** en la entidad mediante un √∫nico atributo.

### **Ejemplo:**

Para la entidad `Libro` con clave compuesta por `titulo` e `idioma`:

```java
@Embeddable
public class IdLibro implements Serializable {
    private String titulo;
    private String idioma;

    // Constructor sin argumentos, constructor completo, equals() y hashCode()
}
```

```java
@Entity
public class Libro {

    @EmbeddedId
    private IdLibro idLibro;

    // Otros atributos, constructores, getters y setters
}
```

---

## 3.7. `@IdClass` vs `@EmbeddedId`

> - **Diferencias principales:**
> 	- **Definici√≥n**
> 		-  Con `@IdClass` se definen los campos de la clave en la entidad y se hace referencia a la clase externa para las operaciones de igualdad.
> 		-  Con `@EmbeddedId` se encapsula la clave compuesta en un √∫nico objeto.
> 	- **Uso en consultas JPQL:**
> 		- `@IdClass`: se accede directamente a los campos, por ejemplo: `SELECT
> 		- `@EmbeddedId`: se debe acceder mediante la propiedad embebida, por ejemplo: `SELECT libro.idLibro.titulo FROM Libro libro`.
> 	- **Conveniencia:**
> 		- `@IdClass` puede ser √∫til si se necesita acceder individualmente a cada parte de la clave.
> 		- `@EmbeddedId` es preferido cuando se usa frecuentemente el identificador completo como objeto.

---

Estos apuntes resumen los conceptos y ejemplos pr√°cticos sobre:

- **Objetos embebidos** en JPA y c√≥mo utilizar `@Embeddable`, `@Embedded`, `@AttributeOverride` y `@AttributeOverrides`.
- La modelaci√≥n de **relaciones muchos a muchos con atributos adicionales** utilizando claves compuestas a trav√©s de `@Embeddable`/`@EmbeddedId` y la alternativa `@IdClass`.
- La aplicaci√≥n pr√°ctica mediante ejercicios enfocados en la gesti√≥n de pel√≠culas, series, calificaciones y relaciones entre entidades.