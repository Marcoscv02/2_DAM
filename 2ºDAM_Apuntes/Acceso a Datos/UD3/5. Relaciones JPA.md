# 1. **Relaciones entre Entidades en JPA** ‚ú®

<aside style="border: 2px solid purple; padding: 10px; border-radius: 5px;"> 
üßÆ Las entidades en JPA suelen estar relacionadas entre s√≠, formando un modelo de entidades y relaciones que refleja las interacciones en una base de datos. Estas relaciones se definen mediante <b>anotaciones</b> que permiten modelar estas conexiones en los atributos de las entidades. A continuaci√≥n, detallaremos todos los conceptos clave sobre relaciones en JPA.
</aside>

---

### üî¨ **Tipos de Relaciones en JPA**

| Anotaci√≥n                                             | Descripci√≥n                   |
| ----------------------------------------------------- | ----------------------------- |
| <span style="color:rgb(255, 0, 0)">@OneToOne</span>   | Relaci√≥n **uno a uno**.       |
| <span style="color:rgb(255, 0, 0)">@OneToMany</span>  | Relaci√≥n **uno a muchos**.    |
| <span style="color:rgb(255, 0, 0)">@ManyToOne</span>  | Relaci√≥n **muchos a uno**.    |
| <span style="color:rgb(255, 0, 0)">@ManyToMany</span> | Relaci√≥n **muchos a muchos**. |

Adem√°s, existen otras anotaciones que complementan y especifican estas relaciones:

| Anotaci√≥n                                                        | Descripci√≥n                                                       |
| ---------------------------------------------------------------- | ----------------------------------------------------------------- |
| <span style="color:rgb(219, 139, 0)">@Embedded</span>            | Relaci√≥n embebida (una entidad dentro de otra).                   |
| <span style="color:rgb(219, 139, 0)">@ElementCollection</span>   | Relaci√≥n **uno a muchos** con dependencia entre entidades.        |
| <span style="color:rgb(219, 139, 0)">@JoinColumn</span>          | Especifica la columna utilizada como clave for√°nea.               |
| <span style="color:rgb(219, 139, 0)">@JoinTable</span>           | Define la tabla intermedia en relaciones.                         |
| <span style="color:rgb(219, 139, 0)">@MapKey</span>              | Define una columna clave en relaciones de tipo mapa.              |
| <span style="color:rgb(219, 139, 0)">@OrderBy</span>             | Ordena los elementos de una relaci√≥n seg√∫n una columna.           |
| <span style="color:rgb(219, 139, 0)">@OrderColumn</span>         | Define una columna para ordenar elementos.                        |
| <span style="color:rgb(219, 139, 0)">@Index</span>               | Crea un √≠ndice en una columna relacionada.                        |
| <span style="color:rgb(219, 139, 0)">@ForeignKey</span>          | Define la clave for√°nea de la relaci√≥n.                           |
| <span style="color:rgb(219, 139, 0)">@AssociationOverride</span> | Sobrescribe configuraciones en una relaci√≥n.                      |
| <span style="color:rgb(219, 139, 0)">@AttributeOverride</span>   | Sobrescribe configuraciones de atributos en una entidad embebida. |
| <span style="color:rgb(219, 139, 0)">@EmbeddedId</span>          | Define una clave primaria compuesta.                              |
| <span style="color:rgb(219, 139, 0)">@IdClass</span>             | Otra forma de definir una clave primaria compuesta.               |

---

## üîé **1.1. Roles en las Relaciones**

En cada relaci√≥n, las entidades tienen **roles**:

1. **Propietario (Owning)**: La entidad que gestiona la relaci√≥n en la base de datos.
2. **Inversor (Non-owning)**: La entidad que no gestiona directamente la relaci√≥n.

‚ñ∂ **Ejemplo**:

En una relaci√≥n bidireccional, el atributo `mappedBy` se usa en el lado inversor para indicar cu√°l es el lado propietario:

```java
@Entity
public class Proyecto {
    @Id
    private int id;
    @ManyToMany(mappedBy = "proyectos") // Lado inversor
    private List<Empleado> empleados;
}
```

---

## üîÄ **1.2. Direccionalidad de las Relaciones**

Las relaciones pueden ser:

- **Unidireccionales**: Solo una entidad referencia a la otra.
- **Bidireccionales**: Ambas entidades se refieren mutuamente.

**üìà Diferencias clave:**

|Relaci√≥n|Lado propietario|Lado inversor|
|---|---|---|
|**Unidireccional**|Solo una entidad referencia.|No aplica.|
|**Bidireccional**|Entidad que gestiona datos.|Entidad que "mapea".|

### **Ejemplo Unidireccional**:

Relaci√≥n `@OneToOne` entre **Empleado** y **Direccion**:

```java
@Entity
public class Empleado {
    @Id
    private int id;
    @OneToOne
    private Direccion direccion; // Propietario de la relaci√≥n
}

@Entity
public class Direccion {
    @Id
    private int id;
    private String calle;
    private String ciudad;
}
```

En esta clase no se puede acceder al empleado a trav√©s de su direcci√≥n

### **Ejemplo Bidireccional**:

Relaci√≥n `@ManyToMany` entre **Empleado** y **Proyecto**:

```java
@Entity
public class Empleado {
    @Id
    private int id;
    @ManyToMany
    private List<Proyecto> proyectos; // Propietario de la relaci√≥n
}

@Entity
public class Proyecto {
    @Id
    private int id;
    @ManyToMany(mappedBy = "proyectos") // Lado inversor
    private List<Empleado> empleados;
}
```

En este caso si se puede acceder al empleado a trav√©s del proyecto en que trabaja

---

## üî¢ **1.3. Cardinalidad de las Relaciones**

La **cardinalidad** define cu√°ntas instancias de una entidad est√°n asociadas a otra. Se especifica mediante las anotaciones:

|Anotaci√≥n|Descripci√≥n|
|---|---|
|`@OneToOne`|Una entidad se relaciona con exactamente una.|
|`@OneToMany`|Una entidad se relaciona con muchas.|
|`@ManyToOne`|Muchas entidades se relacionan con una.|
|`@ManyToMany`|Muchas entidades se relacionan con muchas.|

### Ejemplo `@ManyToOne`:

Relaci√≥n entre **Empleado** y **Departamento**:

```java
@Entity
public class Empleado {
    @Id
    private int id;
    @ManyToOne
    private Departamento departamento;
}

@Entity
public class Departamento {
    @Id
    private int id;
    @OneToMany(mappedBy = "departamento")
    private List<Empleado> empleados;
}
```

**Resultado**:

- **Empleado** tendr√° una columna `departamento_id`.
- **Departamento** no tiene referencia directa a `Empleado`, pero se puede acceder con el atributo `empleados`.

---

## üêû **1.4. Ordinalidad u Opcionalidad**

<aside> ü§î

La **ordinalidad** o **opcionalidad** indica si una entidad destino **debe** existir cuando se crea una entidad origen.

</aside>

### ‚ö° Opcionalidad en c√≥digo:

- `optional = true`: Relaci√≥n opcional (default).
- `optional = false`: Relaci√≥n obligatoria.

‚ñ∂ **Ejemplo**:

```java
@ManyToOne(optional = false) // Departamento es obligatorio
private Departamento departamento;
```

# 2. Relaciones entre Entidades

Las relaciones entre entidades en JPA pueden ser:

- **Many-to-One (Muchos a Uno)**: `@ManyToOne`
- **One-to-One (Uno a Uno)**: `@OneToOne`
- **One-to-Many (Uno a Muchos)**: `@OneToMany`
- **Many-to-Many (Muchos a Muchos)**: `@ManyToMany`

> Cuando existe una asociaci√≥n entre dos entidades, se debe aplicar una de las anotaciones de modelado de relaciones a la propiedad persistente correspondiente o al campo de la entidad referenciadora: `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`. Si no se especifica el tipo de destino (por ejemplo, al usar colecciones sin tipos gen√©ricos), es necesario definir expl√≠citamente la entidad destino de la relaci√≥n.

---

# 3. Relaciones Mono-Valuadas: `@OneToOne` y `@ManyToOne`

<aside> ‚úÖ

Son aquellas¬†**relaciones en las que la¬†cardinalidad del destino es 1**

</aside>

## 3.1. `@OneToOne` Unidireccionales

**Ejemplo**: Un empleado tiene asignado un aparcamiento.

Entidad propietaria de la relaci√≥n:

```java
@Entity
public class Empleado {
    @Id
    private int idEmpleado;
    private String nombre;
    private long salario;

    @OneToOne
    private Aparcamiento aparcamiento; //Lado propietario
    // Getters y Setters
}

@Entity
public class Aparcamiento {
    @Id
    private int idAparcamiento;
    private int numero;
    private String direccion;
    // Getters y Setters
}
```

### **Uso de `@JoinColumn`**:

```java
@Entity
public class Empleado {
    @Id
    private int idEmpleado;
    private String nombre;
    private long salario;

    @OneToOne
    @JoinColumn(name = "idAparcamiento") //Lado propietario
    private Aparcamiento aparcamiento;
    // Getters y Setters
}

@Entity
public class Aparcamiento {
    @Id
    private int idAparcamiento;
    private int numero;
    private String direccion;
    // Getters y Setters
}
```

---

## 3.2. `@OneToOne` Bidireccionales

<aside> üö®

Cuando la entidad objetivo tiene una referencia de vuelta a la entidad origen, se trata de una relaci√≥n bidireccional.

</aside>

**Ejemplo**: El aparcamiento tambi√©n referencia al empleado asignado.

Entidad inversa:

```java
@Entity
public class Empleado {
    @Id
    private int idEmpleado;
    private String nombre;
    private long salario;

    @OneToOne
    @JoinColumn(name = "idAparcamiento") //Lado propietario
    private Aparcamiento aparcamiento;
    // Getters y Setters
}

@Entity
public class Aparcamiento {
    @Id
    private int idAparcamiento;
    private int numero;
    private String direccion;

    @OneToOne(mappedBy = "aparcamiento")
    private Empleado empleado;
    // Getters y Setters
}
```

### **Reglas**:

1. La anotaci√≥n `@JoinColumn` debe estar en el lado propietario (la entidad con la columna de uni√≥n).
2. El elemento `mappedBy` debe estar en el lado inverso de la relaci√≥n.

---

## 3.3. `@ManyToOne` Unidireccional

**Ejemplo**: Relaci√≥n muchos-a-uno entre **Empleado** y **Departamento**.

Entidad con la relaci√≥n:

```java
@Entity
public class Empleado {
    @Id
    private int idEmpleado;
    private String nombre;
    private long salario;

    @ManyToOne
    private Departamento departamento;
    // Getters y Setters
}

@Entity
public class Departamento {
    @Id
    private int idDepartamento;
    private String nombre;
    // Getters y Setters
}
```

### **Uso de `@JoinColumn`**:

```java
@Entity
public class Empleado {
    @Id
    private int idEmpleado;
    private String nombre;
    private long salario;

    @ManyToOne
    @JoinColumn(name = "idDepartamento")
    private Departamento departamento;
    // Getters y Setters
}
```

---

## 3.4. Anotaciones Importantes

### `@JoinColumn`

Se utiliza para especificar una columna de clave for√°nea en una relaci√≥n. Elementos principales:

- **name**: Nombre de la columna de clave for√°nea.
- **referencedColumnName**: Nombre de la columna referenciada (clave primaria).
- **nullable**: Indica si la clave for√°nea puede ser nula.
- **unique**: Indica si la clave for√°nea debe ser √∫nica.

### `@JoinTable`

Se utiliza en relaciones multi-valuadas (como `@ManyToMany`) para definir una tabla intermedia que almacena las claves for√°neas de ambas entidades relacionadas.

---

# **4. Relaciones Multi-Valuadas** ‚úÖ

<aside> üí°

Las relaciones multi-valuadas son aquellas en las que una entidad puede estar asociada con m√°s de una instancia de otra entidad. A continuaci√≥n se explican en detalle las anotaciones principales y sus caracter√≠sticas:

</aside>

## Tipos de Relaciones:

- **@OneToMany**: Relaci√≥n uno-a-muchos.
- **@ManyToMany**: Relaci√≥n muchos-a-muchos.

Ambas se gestionan utilizando colecciones (ej., `Collection`, `List`, `Set`) y la configuraci√≥n de la anotaci√≥n incluye par√°metros clave como `mappedBy` y `@JoinTable`.

---

### ‚òÖ **IMPORTANTE: Uso de `mappedBy`**

### ¬øQu√© hace `mappedBy`?

Indica que **el lado inverso** de la relaci√≥n no es el propietario y no tiene la columna de clave for√°nea en la base de datos.

### Aplicaci√≥n:

- **@OneToMany**: Siempre se recomienda usar `mappedBy` para evitar la creaci√≥n de tablas intermedias no deseadas.
- **@ManyToMany**: Aunque no es obligatorio, su uso permite definir claramente qu√© lado de la relaci√≥n controla la tabla de uni√≥n.

---

## **4.1. @OneToMany**üíØ

### 4.1.1 **Relaci√≥n Bidireccional**

<aside> üí≠

Una relaci√≥n bidireccional one-to-many se establece mediante la anotaci√≥n¬†**`@OneToMany`**

- **siempre implica una**¬†**relaci√≥n¬†`@ManyToOne`¬†en el lado opuesto de la relaci√≥n.** </aside>

Se configura mediante:

- Una colecci√≥n en el lado "UNO" con `@OneToMany(mappedBy=...)`.
    
- Una referencia en el lado "MUCHOS" con `@ManyToOne` y `@JoinColumn`.
    
- **Ejemplo: Departamento y Empleado**
    

```java
@Entity
public class Empleado {
    @Id
    private int idEmpleado;
    private String nombre;
    private long salario;

    @ManyToOne
    @JoinColumn(name = "idDepartamento") //Lado propietario
    private Departamento departamento;
}

@Entity
public class Departamento {
    @Id
    private int idDepartamento;
    private String nombre;

    @OneToMany(mappedBy = "departamento")
    private Collection<Empleado> empleados;
}
```

- **Resultado en Base de Datos:**

|Tabla|Columnas|
|---|---|
|**Empleado**|idEmpleado, nombre, salario, idDepartamento|
|**Departamento**|idDepartamento, nombre|

---

### **4.1.2 Relaci√≥n Unidireccional**

<aside> üîí

En este caso, solo existe referencia desde el lado "UNO" hacia el lado "MUCHOS".

</aside>

- **Ejemplo: Empleado y Tel√©fono**

```java
@Entity
public class Empleado {
    @Id
    private int idEmpleado;
    private String nombre;

    @OneToMany
    @JoinTable(
        name = "EmpleadoTelefono",
        joinColumns = @JoinColumn(name = "idEmpleado"),
        inverseJoinColumns = @JoinColumn(name = "idTelefono")
    )
    private Collection<Telefono> telefonos;
}

@Entity
public class Telefono {
    @Id
    private int idTelefono;
    private String numero;
    private String tipo;
}
```

- **Resultado en Base de Datos:**

|Tabla|Columnas|
|---|---|
|**EmpleadoTelefono**|idEmpleado, idTelefono|
|**Telefono**|idTelefono, numero, tipo|
|**Empleado**|idEmpleado, nombre|

---

## **4.2. @ManyToMany**

<aside> üí≠

- Las relaciones multi-valuadas son aquellas en las que¬†**la cardinalidad del destino es mayor que uno (muchos)**.
- Esta relaci√≥n implica que ambos lados tienen una colecci√≥n que apunta al otro.
- **Siempre requiere una tabla de uni√≥n**. </aside>

### **Ejemplo: Empleado y Proyecto**

```java
@Entity
public class Empleado {
    @Id
    private int idEmpleado;
    private String nombre;

    @ManyToMany
    @JoinTable( //Lado propietario
        name = "EmpleadoProyecto",
        joinColumns = @JoinColumn(name = "idEmpleado"),
        inverseJoinColumns = @JoinColumn(name = "idProyecto")
    )
    private Collection<Proyecto> proyectos;
}

@Entity
public class Proyecto {
    @Id
    private int idProyecto;
    private String nombre;

    @ManyToMany(mappedBy = "proyectos")
    private Collection<Empleado> empleados;
}
```

### Resultado en Base de Datos:

|Tabla|Columnas|
|---|---|
|**EmpleadoProyecto**|idEmpleado, idProyecto|
|**Empleado**|idEmpleado, nombre|
|**Proyecto**|idProyecto, nombre|

---

### ‚úâ Notas Finales:

- Usar **gen√©ricos** en las colecciones para mayor claridad y evitar errores.
- Es importante realizar pruebas para observar el comportamiento por defecto del proveedor JPA cuando:
    - No se define `mappedBy` en relaciones bidireccionales.
    - No se especifica `@JoinTable` en relaciones @ManyToMany.

# 6. Claves compartidas en relaciones uno a unoüìö

<aside> üîí

Una **clave compartida** es una clave primaria que se utiliza en dos o m√°s entidades. En el contexto de relaciones uno a uno, la entidad dependiente puede utilizar la clave primaria de la entidad principal como su propia clave, funcionando tambi√©n como clave for√°nea. Este enfoque se implementa com√∫nmente con la anotaci√≥n `@MapsId`.

</aside>

### üêö**Ejemplo b√°sico:**

En una relaci√≥n bidireccional entre `Empleado` y `HistorialEmpleado` (donde cada empleado tiene un √∫nico historial), se puede compartir la clave primaria:

```java
@Entity
public class HistorialEmpleado {
    // ...
    @Id
    @OneToOne
    @JoinColumn(name="idEmpleado")
    private Empleado empleado;
    // ...
}
```

- **Punto clave:**
    
    La clave primaria de `HistorialEmpleado` tendr√° el mismo tipo que la clave primaria de `Empleado`.
    
    _Ejemplo:_ Si `Empleado` usa un entero, `HistorialEmpleado` tambi√©n usar√° un entero.
    
- **En caso de clave compuesta:**
    
    Si `Empleado` tiene una clave primaria compuesta (por ejemplo, mediante una clase ID o una clase ID incrustada), `HistorialEmpleado` deber√° compartir la misma clase ID (y, normalmente, utilizar `@IdClass`).
    

<aside> üö®

> Nota:
> 
> Esta situaci√≥n es una excepci√≥n a la regla que indica que debe existir un atributo en la entidad para cada atributo en su clase ID, ya que la clase ID se comparte entre la entidad principal y la dependiente.

</aside>

---

## 6.1. Claves compartidas con @MapsId

<aside> ü§ì

La anotaci√≥n `@MapsId` se emplea para indicar que el atributo de relaci√≥n tambi√©n se utiliza para mapear el atributo de identificaci√≥n. Es posible, adem√°s, definir un atributo de clave primaria separado en la entidad que se mapea a la misma columna que la clave for√°nea.

</aside>

**Ejemplo con atributo de clave primaria separado:**

```java
@Entity
public class HistorialEmpleado {
    // ...
    @Id
    int idEmpleado; //Atributo de clave primaria

    @MapsId // Indica que el atributo de relaci√≥n tambi√©n mapea el atributo de ID
    @OneToOne
    @JoinColumn(name="idEmpleado")
    private Empleado empleado;
    // ...
}
```

### ü™¢Aspectos importantes sobre `@MapsId`:

- **Mapping Compartido:**
    
    La relaci√≥n anotada con `@MapsId` **define el mapeo de la columna que se utilizar√° tanto para la clave primaria como para la clave for√°nea**
    
    - _Sin `@JoinColumn`_: Si se omite `@JoinColumn`, **se asignar√° por defecto una columna con el nombre `EntidadRelacionada_idEntidad`** (suponiendo que la clave primaria de la entidad relacionada se llame `idEntidad`).
- **Mapeo de Solo Lectura en el Atributo de Identificaci√≥n:**
    
    Aunque el atributo de identificaci√≥n y el de relaci√≥n se mapean a la misma columna, el atributo de identificaci√≥n es de solo lectura. Esto significa que las actualizaciones o inserciones en dicha columna se realizan a trav√©s del atributo de relaci√≥n.
    
- **Orden de Persistencia:**
    
    Es fundamental establecer y persistir primero la entidad principal (por ejemplo, `Empleado`) antes de persistir la entidad dependiente (`HistorialEmpleado`), ya que la clave primaria se establece a partir de la relaci√≥n.
    

<aside> üö®

> IMPORTANTE ‚Äì Claves compartidas:
> 
> No se debe intentar persistir una entidad dependiente configurando √∫nicamente el atributo de identificaci√≥n (sin la relaci√≥n). Aunque algunos proveedores puedan soportarlo de forma especial, no es una soluci√≥n portable y confiable. El valor del identificador se completa autom√°ticamente al leer la entidad o al ejecutar un flush/commit.

</aside>

---

## 6.2. PrimaryKeyJoinColumn y PrimaryKeyJoinColumns

<aside> ü§î

Estas anotaciones se utilizan para especificar que la columna de clave primaria de una tabla es, a la vez, la columna que sirve como clave for√°nea en la relaci√≥n.

</aside>

- **@PrimaryKeyJoinColumn:**
    
    Se usa en relaciones uno a uno y √∫nicamente en la entidad propietaria de la relaci√≥n. Indica que la columna de la tabla de uni√≥n es la misma que la clave primaria de la entidad.
    
    **Ejemplo:**
    
    ```java
    @Entity
        public class Empleado {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private int idEmpleado;
            private String nombre;
            private long salario;
            
            @OneToOne
            @PrimaryKeyJoinColumn // Indica que la columna de clave primaria de la tabla de uni√≥n es la misma que la clave primaria de la tabla de la ent idad
            private HistorialEmpleado historial;
            // ...
        }
        
        
        
        @Entity
        public class HistorialEmpleado {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private int id;
            private String nombre;
            private long salario;
            // ...
        }
    ```
    
- **@PrimaryKeyJoinColumns:**
    
    Se utiliza cuando la uni√≥n involucra m√∫ltiples columnas de clave primaria (es decir, en casos de claves compuestas).
    

<aside> üôãüèΩ‚Äç‚ôÇÔ∏è

> Nota:
> 
> Si la entidad dependiente (por ejemplo, `HistorialEmpleado`) tiene su propio campo `@Id` para la clave primaria, no tiene sentido usar `@PrimaryKeyJoinColumn` en esa entidad.

</aside>

---

## üåùResumen

- **Claves Compartidas:**
    
    Permiten que la entidad dependiente utilice la clave primaria de la entidad principal, facilitando relaciones uno a uno.
    
- **@MapsId:**
    
    Mapea la clave primaria de la entidad dependiente mediante la relaci√≥n, haciendo que el atributo de identificaci√≥n sea de solo lectura y su valor se derive de la entidad relacionada.
    
- **@PrimaryKeyJoinColumn:**
    
    Se utiliza en la entidad propietaria para indicar que la columna de la clave primaria es la misma que la utilizada para la uni√≥n en la relaci√≥n uno a uno.