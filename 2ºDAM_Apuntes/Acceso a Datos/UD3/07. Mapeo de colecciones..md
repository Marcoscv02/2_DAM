[[6. Objetos Embebidos]]
# 1Ô∏è. Relaciones y colecciones de elementos (@ElementCollection)

### üîó Tipos de objetos que pueden contener colecciones:

- **Entidades** (`@OneToMany`, `@ManyToMany`)
    
- **Elementos embebidos** (`@ElementCollection`)
    
- **Elementos b√°sicos** (`@ElementCollection`)
    


<aside style="border: 2px solid red; padding: 10px; border-radius: 5px;"> 
‚ùó <b>Las colecciones de elementos embebidos y b√°sicos no son relaciones, sino dependientes de la entidad principal.</b>
</aside>

### üîç Ejemplo:

```java
// Colecci√≥n de elementos b√°sicos (String)
@Entity
public class Persona {
    @Id private Long id;
    @ElementCollection
    private List<String> telefonos; // Tabla: Persona_telefonos
}

// Colecci√≥n de elementos embebidos (Vacaciones)
@Embeddable
public class Vacaciones {
    private LocalDate fechaInicio;
    private int duracion;
}

@Entity
public class Persona {
    @Id private Long id;
    @ElementCollection
    private List<Vacaciones> vacaciones; // Tabla: Persona_vacaciones
}
```

‚úçÔ∏è En este caso, la lista `telefonos` es una colecci√≥n de elementos **b√°sicos**, no una relaci√≥n independiente.

### ü•® @ElementCollection
>- La¬†[anotaci√≥n¬†`@ElementCollection`](https://jakarta.ee/specifications/persistence/3.1/apidocs/jakarta.persistence/jakarta/persistence/elementcollection)¬†se utiliza para¬†**mapear colecciones de elementos embebidos o b√°sicos**. Dispones de dos elementos opcionales:
	>	- `targetClass`: de¬†[tipo Class](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Class.html) Clase de los elementos (si no hay gen√©ricos). Opcional en caso de colecci√≥n con tipos gen√©ricos
	>	- `fetch`: de¬†[tipo¬†`FechType`](https://jakarta.ee/specifications/persistence/3.1/apidocs/jakarta.persistence/jakarta/persistence/fetchtype)¬†tipo de carga de los elementos de la colecci√≥n¬°¬†**Por defecto es perezosa**.

---
# 2Ô∏è. Tabla de colecci√≥n: @CollectionTable


<aside style="border: 2px solid green; padding: 10px; border-radius: 5px;"> 
üí° La anotaci√≥n¬†@CollectionTable¬†se utiliza para¬†<b>especificar la tabla de la colecci√≥n</b>.
</aside>

Cuando se mapean colecciones de elementos embebidos o b√°sicos, no se pueden almacenar varios valores en una sola columna. Por ello, se utiliza una **tabla de colecci√≥n** para guardar dichos elementos de forma independiente.

 ### üîç Ejemplo:

``` java
@Entity
public class Persona {
    @Id
    private long id;
    private String nombre;
    @ElementCollection
    @CollectionTable(name="Vacaciones", joinColumns=@JoinColumn(name="idPersona"))
    private Collection<Vacaciones> vacaciones;
}
```

- La tabla **Vacaciones** se crea para almacenar los elementos de la colecci√≥n `vacaciones`.
- La columna `idPersona` act√∫a como clave for√°nea que enlaza cada elemento con la entidad `Persona`.

### Comportamiento por defecto

Si no se especifica `@CollectionTable`, se usar√° una tabla con el nombre formado por la entidad y el nombre de la propiedad, separados por un guion bajo.  
_Ejemplo:_ La colecci√≥n `vacaciones` de `Persona` se almacenar√≠a en la tabla **Persona_Vacaciones**.

## 2.1Ô∏è Columnas de colecci√≥n: @Column


<aside style="border: 2px solid orange; padding: 10px; border-radius: 5px;"> 
üìå <b>Uso:</b><br>  
Personaliza el nombre de las columnas en la tabla de la colecci√≥n.
</aside>

- **Con colecciones de tipos b√°sicos:**  
    El nombre de la columna se deriva del campo o propiedad, pero se puede sobrescribir:
``` java
@ElementCollection // usa la tabla por defecto: Persona_telefonos
@Column(name="telefono")
private List<String> telefonos;
```
- **Con colecciones de elementos embebidos:**  
    Los nombres por defecto son los de las propiedades del embebido, pero se pueden sobrescribir usando `@AttributeOverride` o `@AttributeOverrides`:

```java
@ElementCollection
@CollectionTable(name="Residencia")
@AttributeOverrides({
    @AttributeOverride(name="calle", column=@Column(name="calleCasa")),
    @AttributeOverride(name="ciudad", column=@Column(name="ciudadCasa")),
    @AttributeOverride(name="provincia", column=@Column(name="provinciaCasa"))
})
private Set<Direccion> direcciones = new HashSet<>();

```
#### üîç Ejemplo completo
```java
@Embeddable 
public class Direccion {
    protected String calle;
    protected String ciudad;
    protected String provincia;
    // ...
}

@Entity 
public class Persona {
    @Id 
    protected String numeroSeguridadSocial;
    protected String nombre;
    protected Direccion casa;
    // ...
    
    @ElementCollection  // usa la tabla por defecto: Persona_Alias
    @Column(name="nombre", length=50)
    protected Set<String> alias = new HashSet<>();
    // ...
}

@Entity 
public class Medico extends Persona {
    @ElementCollection
    @CollectionTable(name="Casa") // usa el nombre por defecto de la clave for√°nea.
    @AttributeOverrides({
            @AttributeOverride(name="calle", column=@Column(name="calleCasa")),
            @AttributeOverride(name="ciudad", column=@Column(name="ciudadCasa")),
            @AttributeOverride(name="provincia", column=@Column(name="provinciaCasa"))
    })
    protected Set<Direccion> casas = new HashSet<>();
    // ...
}

```

| Elemento                                                          | Descripci√≥n                                      | Ejemplo de Anotaci√≥n                                                             |
| ----------------------------------------------------------------- | ------------------------------------------------ | -------------------------------------------------------------------------------- |
| <span style="color:rgb(0, 176, 240)">Tabla de colecci√≥n</span>    | Define la tabla donde se almacenan los elementos | `@CollectionTable(name="Vacaciones", joinColumns=@JoinColumn(name="idPersona"))` |
| <span style="color:rgb(0, 176, 240)">Columna personalizada</span> | Sobrescribe el nombre de la columna en la tabla  | `@Column(name="telefono")`                                                       |
# 3Ô∏è. Ordenaci√≥n de colecciones

Ordenar los elementos en una colecci√≥n es esencial para ciertos casos de uso. Existen dos m√©todos principales:

## 3.1Ô∏è @OrderBy

### üî¢ Funci√≥n:  
Ordena los elementos de una colecci√≥n (ya sean b√°sicos, embebidos o relaciones) bas√°ndose en los atributos especificados.
- **Sintaxis**:
    ```java
	`@OrderBy("propiedad1 [ASC|DESC], propiedad2 [ASC|DESC], ...")`
	```
- üîç**Ejemplo: Ordenar por fecha de inicio descendente:**
	```java
	@Entity
	public class Curso {
	    // ...
	    @ManyToMany
	    @OrderBy("apelidos ASC")
	    public List<Estudante> getEstudantes() {
	        //...
	    }
	    // ...
	}
	```
- **Uso de notaci√≥n de punto:**  
    Para ordenar por una propiedad dentro de un elemento embebido:
	```java
	@Entity 
	public class Persona {
	    @Id
	    private long idPersona;
	    private String nome;
	    
	    @ElementCollection
	    @OrderBy("rua ASC")
	    private List<Direccion> direccions;
	    // ...
	}
	```
- **Ordenaci√≥n por varias propiedades:**
	```java
	@Entity 
	public class Persona {
	    @Id
	    private long id;
	    private String nombre;
	    
	    @ElementCollection
	    @OrderBy("fechaInicio DESC, duracion ASC")
	    private List<Vacaciones> vacaciones;
	    // ...
	}
	```
- **Aplicable a relaciones de tipo List (por ejemplo, en `@OneToMany` o `@ManyToMany`):**
	```java
	@Entity
	public class Curso {
	    // ...
	    @ManyToMany
	    @OrderBy("apelidos ASC")
	    public List<Estudante> getEstudantes() {
	        //...
	    }
	    // ...
	}
	```
## 3.2Ô∏è @OrderColumn

### üî¢ Funci√≥n:  
Mantiene el orden de la colecci√≥n almacenando el √≠ndice de cada elemento en una columna extra de la tabla de la colecci√≥n.

 
<aside style="border: 2px solid red; padding: 10px; border-radius: 5px;"> 
<b>‚ùóImportante:</b><br>  
    El uso de `@OrderColumn` es <b>incompatible</b> con `@OrderBy` (se debe usar uno u otro).
</aside>

- üîç **Ejemplo especificando el nombre de la columna:**
	```java
	@Entity 
	public class Estudiante {
	    @Id
	    private long idEstudiante;
	    private String nombre;
	    
	    @OneToMany(mappedBy="estudiante")
	    @OrderColumn(name="orden")
	    private List<Materia> materias;
	    // ...
	}
	``` 
- üîç ** Ejemplo sin especificar el nombre (usar√° el valor por defecto):**
	```java
	@Entity 
	public class Estudiante {
	    @Id
	    private long idEstudiante;
	    private String nombre;
	    
	    @OneToMany(mappedBy="estudiante")
	    @OrderColumn
	    private List<Materia> materias;
	    // ...
	}

	```
---

# 4Ô∏è. Generaci√≥n de claves primarias para colecciones de elementos: @CollectionId (Hibernate) (*)


<aside style="border: 2px solid purple; padding: 10px; border-radius: 5px;"> 
‚ö†Ô∏è <b>Nota:</b><br>  
Esta anotaci√≥n es exclusiva de Hibernate (no es parte de JPA) y se utiliza para generar claves primarias para elementos en colecciones de elementos b√°sicos o embebidos.
</aside>

### üîç Ejemplo de uso:
```java
@Entity 
public class Persona {
    @Id
    private long id;
    private String nombre;
    
    @ElementCollection
    @CollectionId(
        columns=@Column(name="idVacaciones"), 
        type=@Type(type="long"), 
        generator="sequence"
    )
    private Collection<Vacaciones> vacaciones;
    // ...
}
```
- La colecci√≥n `vacaciones` obtendr√° una clave primaria generada a partir de una secuencia.
---
# 5Ô∏è. üîç Ejemplo de mapeo de colecciones

Este ejemplo muestra c√≥mo mapear tanto una colecci√≥n de elementos b√°sicos como una de elementos embebidos:

```java
	@Entity 
	public class Persona {
	    @Id
	    private long idPersona;
	    private String nombre;
	    
	    // Colecci√≥n de elementos b√°sicos: fechas
	    @ElementCollection
	    @CollectionTable(name="Vacaciones", joinColumns=@JoinColumn(name="idPersona"))
	    @Column(name="fechaInicio")
	    private Collection<Date> vacaciones;
	    
	    // Colecci√≥n de elementos embebidos: direcciones
	    @ElementCollection
	    @CollectionTable(name="Direccion", joinColumns=@JoinColumn(name="idPersona"))
	    @AttributeOverrides({
	        @AttributeOverride(name="calle", column=@Column(name="calleCasa")),
	        @AttributeOverride(name="ciudad", column=@Column(name="ciudadCasa")),
	        @AttributeOverride(name="provincia", column=@Column(name="provinciaCasa"))
	    })
	    private Collection<Direccion> direcciones;
	    // ...
	}

```
- Se crean dos tablas:
    - **Vacaciones**: Almacena las fechas de vacaciones (clave for√°nea: `idPersona`).
    - **Direccion**: Almacena las direcciones, con columnas personalizadas para `calle`, `ciudad` y `provincia`.

Adem√°s, se incluye un ejemplo de ordenaci√≥n en relaciones `@ManyToMany`:
```java
@Entity 
public class Curso {
   // ...
   @ManyToMany
   @OrderBy("apelidos ASC")
   public List<Estudante> getEstudantes() {
       // ...
   }
   // ...
}

@Entity
public class Estudiante {
    // ...
    @ManyToMany(mappedBy="estudantes")
    @OrderBy  // ordena por clave primaria
    public List<Curso> getCurso() {
        //...
    }
    // ...
}

```
---

# 6Ô∏è One-to-many vs @ElementCollection

## 6.1 Anotaciones One to Many

### üõë Cu√°ndo usar:  
Se emplean cuando se crea una relaci√≥n entre dos entidades independientes (cada una con su propia tabla en la base de datos).

### üîç Ejemplo: Relaci√≥n entre `Tienda` y `Sucursal`

**Tienda.java:**
```java
@Entity
@Table(name = "tienda")
public class Tienda {
    @Id    
    @GeneratedValue(strategy = GenerationType.IDENTITY)    
    private Long idTienda;    
    
    @Column(name = "nome")    
    private String nome; 
    
    @Column(name = "url")    
    private String url;
    
    @OneToMany(mappedBy = "tienda", cascade = CascadeType.ALL)       
    private Set<Sucursal> sucursales = new HashSet<>();
}

```

**Sucursal.java:**
```java
@Entity
@Table(name = "sucursal")
public class Sucursal {
    @Id    
    @GeneratedValue(strategy = GenerationType.IDENTITY)    
    private Long idSucursal;
    
    @Column(name = "nome")    
    private String nome;
    
    @Column(name = "url")    
    private String url;
    
    @ManyToOne
    private Tienda tienda;
}

```
- Al ejecutar este c√≥digo, se crean dos tablas: **tienda** y **sucursal**.
- Se deben crear repositorios/DAO para interactuar con ambas entidades (por ejemplo, usando Spring Data JPA con la anotaci√≥n `@Repository`).

**Repositorio para Tienda:**
```java
@Repository
public interface TiendaRepository extends JpaRepository<Tienda,Long> {
}
```
**Repositorio para Sucursal:**
```java
@Repository
public interface SucursalRepository extends JpaRepository<Sucursal,Long> {
}
```
## 6.2 Anotaci√≥n `@ElementCollection`

### üõë Cu√°ndo usar:  
Se utiliza para mapear colecciones de elementos que no son entidades independientes, sino tipos simples o embebidos.

- Los elementos dependen completamente de la entidad contenedora.
- No se pueden consultar, persistir o fusionar (merge) de forma independiente.

### üîç Ejemplo: Uso de `@ElementCollection` para una colecci√≥n de productos embebidos

**Producto.java:**
```java
@Embeddable
public class Producto {
    // No se requiere id, pues no es una entidad
    @Column(name="nome")
    private String nome;
    
    @Column(name="precio")
    private Double precio;
}

```

**Tienda.java (con productos embebidos):**
```java
@Entity
@Table(name = "tienda")
public class Tienda {
    @Id    
    @GeneratedValue(strategy = GenerationType.IDENTITY)    
    private Long idTienda;
    
    @Column(name = "nome")    
    private String nome;
    
    @Column(name = "url")    
    private String url;
    
    @OneToMany(mappedBy = "tienda", cascade = CascadeType.ALL)       
    private Set<Sucursal> sucursales = new HashSet<>();
    
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(
        name = "ProductoTienda", 
        joinColumns = @JoinColumn(name = "idTienda", nullable = false), 
        uniqueConstraints = @UniqueConstraint(columnNames = {"idTienda"})
    )
    private Set<Producto> products = new HashSet<>();
}

```
- La tabla **ProductoTienda** se crea para almacenar los productos asociados a la tienda.
- El objeto `Producto` (Embeddable) no tiene un ciclo de vida propio ni repositorio, ya que depende de la entidad `Tienda`.

## 6.3Diferencias Clave entre ambos enfoques

| Aspecto                                                  | @OneToMany (Entidad)                           | @ElementCollection (Embebido/B√°sico)                               |
| -------------------------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------------ |
| <span style="color:rgb(0, 17, 255)">Relaci√≥n</span>      | Relaci√≥n entre entidades independientes        | Colecci√≥n de valores simples o embebidos                           |
| <span style="color:rgb(0, 17, 255)">Ciclo de vida</span> | Independiente (puede consultarse por separado) | Depende totalmente de la entidad contenedora                       |
| <span style="color:rgb(0, 17, 255)">Repositorios</span>  | Cada entidad tiene su propio repositorio       | No se crea repositorio; se accede a trav√©s de la entidad principal |
| <span style="color:rgb(0, 17, 255)">Operaciones</span>   | Permite operaciones de cascada personalizadas  | No admite operaciones de cascada independientes                    |

---

## üéÉ **Resumen Final**

>- **`@ElementCollection`:**  
  >  Se utiliza para mapear colecciones de elementos embebidos o b√°sicos.
>
  > 	 - Los elementos no son entidades independientes.
   > 	- Permite definir atributos como `targetClass` y `fetch`.
   
>- **`@CollectionTable`:**  
    >Especifica la tabla donde se almacenar√°n los elementos de la colecci√≥n, junto con las claves for√°neas.
    
>- **`@Column` y `@AttributeOverride`:**  
    >Permiten personalizar los nombres y caracter√≠sticas de las columnas en la tabla de la colecci√≥n.
    
>- **Ordenaci√≥n de colecciones:**
  >  
 >   - **`@OrderBy`:** Ordena por atributos de los elementos.
 >   - **`@OrderColumn`:** Mantiene el orden usando una columna de √≠ndice.
 
>- **`@CollectionId` (Hibernate):**  
  >  Permite generar claves primarias para colecciones (caracter√≠stica exclusiva de Hibernate).
    
>- **Diferencia entre `@OneToMany` y `@ElementCollection`:**
  >  
 >   - **`@OneToMany`:** Se usa cuando se requiere que los objetos relacionados sean entidades con ciclo de vida independiente.
 >   - **`@ElementCollection`:** Se utiliza para colecciones de valores o embebidos que dependen completamente de la entidad principal.

---

## üó∫Ô∏è **Diagrama Visual de la Estructura de Colecciones**
```mermaid
graph LR
    %% Entidades principales
    A[Entidad: Persona] -->|@ElementCollection| B[(Tabla Colecci√≥n: Persona_Vacaciones)]
    C[Entidad: Tienda] -->|@OneToMany| D[Entidad: Sucursal]
    
    %% Elementos embebidos/b√°sicos
    E[Embeddable: Vacaciones] --> B
    F[String] -->|Elemento b√°sico| B
    
    %% Relaciones OneToMany
    D -->|@ManyToOne| C
    
    %% Estilos
    class A,C,D,E entityClass;
    class B,F collectionClass;
    classDef entityClass fill:#f9f,stroke:#333;
    classDef collectionClass fill:#bbf,stroke:#333;
```

> **Consejo de estudio:**  
> Revisa cada ejemplo y practica implementando tanto colecciones b√°sicas como embebidas. Comprende cu√°ndo es apropiado usar `@ElementCollection` versus una relaci√≥n de entidades para garantizar la integridad y facilidad de acceso a los datos.