# **1. IntroducciÃ³n ğŸŒ**

<aside  style="border: 2px solid purple; padding: 10px; border-radius: 5px;"> 
ğŸ­ El mapeo objeto-relacional (ORM) es la base de JPA, permitiendo conectar el mundo de los objetos en Java con las bases de datos relacionales.
</aside>

Esto incluye:

- ğŸ§© **Correspondencia de atributos del objeto con columnas de la base de datos.**
- ğŸ” **EjecuciÃ³n de consultas entre objetos.**

El mapeo de objetos se realiza a traves de anotaciones que van precedidas por el simbolo `@`

## **ğŸ”– Anotaciones de Persistencia**

<aside style="border: 2px solid yellow; padding: 10px; border-radius: 5px;"> 
 ğŸ’¡Las anotaciones en JPA proporcionan una manera sencilla y flexible de definir el comportamiento de persistencia.
</aside>

>- **CaracterÃ­sticas clave de las anotaciones:**
  > 	 - ğŸ“Œ **UbicaciÃ³n:** Se colocan en clases, mÃ©todos o atributos.
  > 	 - ğŸ“œ **Sintaxis:** Antes de la definiciÃ³n de la clase, atributo o mÃ©todo correspondiente.
  > 	 - ğŸ¤” **Flexibilidad:** Las anotaciones pueden aplicarse a atributos o mÃ©todos dependiendo de tus preferencias.

| **Tipo de AnotaciÃ³n**                                           | **DescripciÃ³n**                                                 | **Ejemplos**                   |
| --------------------------------------------------------------- | --------------------------------------------------------------- | ------------------------------ |
| <span style="color:rgb(255, 0, 0)"><u><b>LÃ³gicas</b></u></span> | Modelan entidades desde la perspectiva del modelado de objetos. | `@Entity`, `@Id`, `@ManyToOne` |
| <span style="color:rgb(255, 0, 0)"><u><b>FÃ­sicas</b></u></span> | Se enfocan en el modelo de datos de la base de datos            | `@Table`, `@Column`            |

---

### **Ejemplo bÃ¡sico:**

```java
@Entity
public class Producto {
    @Id
    private Long id;
    private String nombre;
    private double precio;
}
```

> Nota: TambiÃ©n puedes definir metadatos equivalentes en XML, pero las anotaciones son el enfoque preferido para aplicaciones modernas.

---

# **2. Modos de Acceso a una Entidad ğŸ› ï¸**

El modo de acceso indica cÃ³mo el proveedor de persistencia interactÃºa con el estado de las entidades.

### **ğŸ”‘ Tipos de Acceso**

1. **Acceso por atributo:** Usando reflexiÃ³n en los atributos directamente.
2. **Acceso por propiedad:** A travÃ©s de mÃ©todos `getter` y `setter`.
3. **Acceso mixto:** Combina ambos enfoques segÃºn las necesidades.

---

## **2.1 Acceso por Atributo**

Las anotaciones se colocan directamente sobre los atributos.

<aside style="border: 2px solid red; padding: 10px; border-radius: 5px;"> 
â›” Todos losÂ <b>atributos deben declararse comoÂ `protected` oÂ `private`</b>.Â  <b>SeÂ prohÃ­ben los atributosÂ `public`</b>.
</aside>

### ğŸª¢ CaracterÃ­sticas:

- **Anotaciones en los atributos**: Las anotaciones, como `@Id`, se colocan directamente sobre los atributos.
- Los mÃ©todos getter y setter pueden estar presentes, pero no son utilizados por el proveedor.
- Los atributos deben tener visibilidad **private**, **protected** o **de paquete (default)**, pero no **public**.
- Este mÃ©todo es preferido cuando se desea mayor control sobre los datos o cuando no se quiere exponer directamente el estado persistente.

### **Ejemplo:**

```java
@Entity
public class Employee {
    @Id
    private Long id;       // AnotaciÃ³n directamente en el atributo.
    private String name;   // Nombre persistente, mapeado por defecto.
    private long salary;   // Salario persistente, mapeado por defecto.

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public long getSalary() { return salary; }
    public void setSalary(long salary) { this.salary = salary; }
}
```

| **Ventajas**âœ…     | **Desventajas**âŒ                                  |
| ----------------- | ------------------------------------------------- |
| ğŸš€ Simplicidad.   | Menor control sobre getters y setters.            |
| ğŸ‘“ FÃ¡cil de leer. | No se pueden aplicar validaciones en los mÃ©todos. |

---

## **2.2 Acceso por Propiedad**

Las anotaciones se colocan en los mÃ©todos `getter`.

<aside style="border: 2px solid red; padding: 10px; border-radius: 5px;"> 
â›” Cuando se utiliza el modo de acceso por propiedadÂ <b>debe haber mÃ©todosÂ _getter_Â yÂ _setter_Â para las propiedades persistentes</b>.
</aside>

### ğŸš CaracterÃ­sticas:

- ElÂ **tipo de propiedad**Â se determina por elÂ **tipo devuelto del mÃ©todoÂ _getter_**Â yÂ **debe ser el mismo que el tipo del Ãºnico parÃ¡metro pasado al mÃ©todoÂ _setter_**.
- Ambos mÃ©todosÂ **deben tener visibilidadÂ `public`Â oÂ `protected`**
- Ãštil cuando se necesita lÃ³gica adicional al acceder o modificar los datos.

### Ejemplo:

```java
@Entity
public class Employee {
    private long id;       // No anotado directamente, usado solo internamente.
    private String name;   // Nombre persistente accesible por getter y setter.
    private long wage;     // Respalda la propiedad `salary`.

    @Id
    public long getId() { return id; }  // AnotaciÃ³n en el getter.
    public void setId(long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public long getSalary() { return wage; }  // Getter y setter conectan con `wage`.
    public void setSalary(long salary) { this.wage = salary; }
}

```

| **Ventajas**âœ…                      | **Desventajas**âŒ       |
| ---------------------------------- | ---------------------- |
| ğŸ›ï¸ Mayor control sobre los datos. | ğŸ› ï¸ Mayor complejidad. |
| ğŸ’¾ Permite validaciones.           |                        |

---

## **2.3 Acceso Mixto**

El acceso mixto combina los modos de acceso **por atributo** y **por propiedad** dentro de una misma entidad o en una jerarquÃ­a de entidades.

### ğŸŒµ CaracterÃ­sticas:

- El modo predeterminado se especifica a nivel de clase con la anotaciÃ³n `@Access`.
- Se puede anular el modo de acceso predeterminado en atributos o propiedades individuales.
- Ideal para casos donde se requiere una **transformaciÃ³n de datos** o cuando se heredan entidades con diferentes requisitos de acceso.
- Permite usar diferentes enfoques dentro de una misma entidad.

### Ejemplo:

Una entidad que usa acceso por atributo como predeterminado, pero incluye una propiedad con acceso por getter para realizar una transformaciÃ³n:

```java
@Entity
@Access(AccessType.FIELD)  // Acceso predeterminado por atributo.
public class Employee {
    @Id
    private long id;       // Acceso directo a travÃ©s del atributo.
    @Transient
    private String phoneNum;  // No se persiste directamente.

    public static final String LOCAL_AREA_CODE = "613";

    public long getId() { return id; }
    public void setId(long id) { this.id = id; }

    public String getPhoneNumber() { return phoneNum; }
    public void setPhoneNumber(String num) { this.phoneNum = num; }

    @Access(AccessType.PROPERTY)
    @Column(name = "PHONE")
    protected String getPhoneNumberForDb() {
        if (phoneNum.length() == 10)
            return phoneNum;  // Sin transformaciÃ³n.
        else
            return LOCAL_AREA_CODE + phoneNum;  // AÃ±ade cÃ³digo de Ã¡rea.
    }

    protected void setPhoneNumberForDb(String num) {
        if (num.startsWith(LOCAL_AREA_CODE))
            phoneNum = num.substring(3);  // Elimina el cÃ³digo de Ã¡rea.
        else
            phoneNum = num;
    }
}
```

---

# **3. Mapeo a una Tabla concreta: `@Table`** ğŸ“‹

<aside> 

ğŸ’¡La anotaciÃ³n `@Table` en JPA permite configurar cÃ³mo una entidad Java se asocia con una tabla especÃ­fica en la base de datos. Aunque el mapeo bÃ¡sico solo requiere `@Entity` e `@Id`, `@Table` ofrece mÃ¡s control sobre los nombres de tablas, esquemas y catÃ¡logos.

</aside>

---

## **3.1. Nombre de la tabla**

Por defecto, el nombre de la tabla serÃ¡ el nombre de la clase de la entidad sin cualificar. Sin embargo, puedes personalizarlo usando el atributo `name` de `@Table`.

```java
@Entity
@Table(name = "EMP")
public class Employee {
    @Id
    private Long id;
    private String name;
}
```

- **Predeterminado:** Si no se especifica, el nombre de la tabla serÃ¡ `Employee`.
- **Personalizado:** Con `@Table(name = "EMP")`, el nombre serÃ¡ `EMP`.

### ğŸ™ˆConsejo

>Los nombres predeterminados no se especifican como sensibles a mayÃºsculas o minÃºsculas. Sin embargo, algunas bases de datos, como MySQL y H2, manejan esta caracterÃ­stica de forma diferente:

- **MySQL:** Insensible por defecto.
- **H2:** Sensible a mayÃºsculas/minÃºsculas, salvo que se configure `IGNORECASE=TRUE` en la URL de conexiÃ³n.

```
jdbc:h2:~/test;IGNORECASE=TRUE
```

---

## **3.2. Esquemas**

Puedes especificar el esquema en el atributo `schema` de `@Table`. Esto permite organizar tablas dentro de diferentes contextos lÃ³gicos en la base de datos.

```java
@Entity
@Table(name = "EMP", schema = "HR")
public class Employee {
    @Id
    private Long id;
    private String name;
}
```

- En este caso, el proveedor de persistencia buscarÃ¡ la tabla como **`HR.EMP`**.

### ğŸ’­Consejo

>Algunos proveedores permiten incluir el esquema directamente en el atributo `name` como `@Table(name = "HR.EMP")`. Sin embargo, esto **no es estÃ¡ndar** y puede limitar la portabilidad de la aplicaciÃ³n.

---

## **3.3. CatÃ¡logos**

Para bases de datos que admiten catÃ¡logos, el atributo `catalog` en `@Table` permite especificarlos.

```java
@Entity
@Table(name = "EMP", catalog = "HR")
public class Employee {
    @Id
    private Long id;
    private String name;
}
```

- AquÃ­, la tabla `EMP` estarÃ¡ contenida en el catÃ¡logo **`HR`**.

---

## **3.4. Nombres sensibles a mayÃºsculas de tablas y columnas**

El estÃ¡ndar SQL establece que los identificadores de base de datos no delimitados no son sensibles a mayÃºsculas o minÃºsculas. Sin embargo, **si es necesario distinguir entre identificadores, deben delimitarse con comillas dobles (`"`).**

### Ejemplos de nombres equivalentes en bases de datos estÃ¡ndar:

```java
@Table(name = "autor")
@Table(name = "Autor")
@Table(name = "AUTOR")
```

- Todos los nombres anteriores hacen referencia a la misma tabla.

### Ejemplo con identificadores delimitados:

En una base de datos sensible a mayÃºsculas, las siguientes anotaciones **se referirÃ­an a tablas distintas**:

```java
@Table(name = "\\"Autor\\"")
@Table(name = "\\"AUTOR\\"")
```

---

# **4. Mapeo de Tipos Simples** ğŸ—ºï¸

<aside> 

ğŸ’¡ Los tipos simples de Java se pueden mapear directamente a columnas en la base de datos. A continuaciÃ³n, se enumeran los tipos compatibles que se pueden usar en las entidades JPA:

</aside>

---

## **4.1. Tipos primitivos de Java**

Estos se asignan automÃ¡ticamente a tipos compatibles en la base de datos:

- <span style="color:rgb(255, 0, 0)"><b>NÃºmeros enteros y decimales:</b></span>`byte`, `short`, `int`, `long`, `float`, `double`.
- <span style="color:rgb(255, 0, 0)"><b>Otros:</b></span>`char`, `boolean`.

---

## **4.2. Clases envolventes de tipos primitivos**

Estas clases proporcionan un mapeo similar a sus contrapartes primitivas:

- <span style="color:rgb(255, 0, 0)"><b>Enteros y decimales:</b></span>`Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`.
- <span style="color:rgb(255, 0, 0)"><b>Otros:</b></span>`Character`, `Boolean`.

---

## **4.3. Arrays de bytes y caracteres**

Se utilizan para almacenar datos como blobs o secuencias de caracteres:

- `byte[]`, `Byte[]`, `char[]`, `Character[]`.

---

## **4.4. Tipos numÃ©ricos grandes**

Para datos numÃ©ricos que necesitan una precisiÃ³n adicional:

- `java.math.BigInteger`.
- `java.math.BigDecimal`.

---

## **4.5. Cadenas**

Para almacenar textos, puedes usar:

- `java.lang.String`.

---

## **4.6. Tipos temporales de Java**

JPA permite el uso de una variedad de tipos temporales para fechas y horas:

- **Java Util:**
    - `java.util.Date`.
    - `java.util.Calendar`.
- **API de Java 8 (`java.time`):**
    - `java.time.LocalDate`.
    - `java.time.LocalTime`.
    - `java.time.LocalDateTime`.
    - `java.time.OffsetTime`.
    - `java.time.OffsetDateTime`.

> ğŸ—’ï¸Nota: Para tipos como java.time.Instant, se necesita un AttributeConverter.

---

## **4.7. Tipos temporales de JDBC**

Compatibles con las funciones especÃ­ficas de JDBC:

- `java.sql.Date`.
- `java.sql.Time`.
- `java.sql.Timestamp`.

---

## **4.8. Tipos enumerados**

Cualquier tipo enumerado definido por el sistema o por el usuario.

---

## **4.9. Objetos serializables**

Puedes mapear cualquier tipo que sea serializable en Java.

---

## ğŸ—’ï¸**Nota**

> Si el tipo de Java no coincide directamente con el tipo JDBC, algunos proveedores de persistencia pueden realizar conversiones automÃ¡ticas. Si esto no es posible, serÃ¡ necesario implementar un AttributeConverter.

---

# **5. Mapeo de columnas: `@Column`** ğŸ›ï¸

Aunque los campos bÃ¡sicos son persistentes por defecto, la anotaciÃ³n `@Column` permite definir atributos especÃ­ficos de las columnas asociadas.

### ğŸ§§Elementos de la anotaciÃ³n `@Column`:

| **Elemento**                                                      | **DescripciÃ³n**                                           | **Valor Predeterminado** |
| ----------------------------------------------------------------- | --------------------------------------------------------- | ------------------------ |
| <span style="color:rgb(255, 0, 0)"><b>name</b></span>             | Nombre de la columna en la base de datos.                 | Nombre del atributo.     |
| <span style="color:rgb(255, 0, 0)"><b>length </b></span>          | Longitud mÃ¡xima de cadenas o arrays de caracteres.        | `255`                    |
| <span style="color:rgb(255, 0, 0)"><b>unique </b></span>          | Define si los valores deben ser Ãºnicos.                   | `false`                  |
| <span style="color:rgb(255, 0, 0)"><b>nullable </b></span>        | Permite valores nulos en la columna.                      | `true`                   |
| <span style="color:rgb(255, 0, 0)"><b>insertable</b></span>       | Si la columna se incluye en operaciones de inserciÃ³n.     | `true`                   |
| <span style="color:rgb(255, 0, 0)"><b>updatable </b></span>       | Si la columna se incluye en operaciones de actualizaciÃ³n. | `true`                   |
| <span style="color:rgb(255, 0, 0)"><b>precisiÃ³n</b></span>        | PrecisiÃ³n numÃ©rica para valores decimales.                | `0`                      |
| <span style="color:rgb(255, 0, 0)"><b>scale</b></span>            | Escala numÃ©rica para valores decimales.                   | `0`                      |
| <span style="color:rgb(255, 0, 0)"><b>columnDefinition</b></span> | DefiniciÃ³n SQL directa para la columna (menos portable).  | Ninguna.                 |

### Ejemplo de uso:

```java
java
CopiarEditar
@Entity
public class Employee {
    @Id
    @Column(name = "EMP_ID", nullable = false, unique = true)
    private long id;

    @Column(name = "NAME", length = 100, nullable = false)
    private String name;

    @Column(name = "SALARY", precision = 10, scale = 2)
    private BigDecimal salary;

    @Column(name = "COMMENTS", columnDefinition = "TEXT")
    private String comments;
}

```

### ğŸ—’ï¸Nota

> La combinaciÃ³n de `@Column` y `@Table` permite un control total sobre el mapeo entre las clases y la base de datos, garantizando una mayor flexibilidad y portabilidad.

---

# **6. Carga Perezosa (Lazy Fetching)** ğŸ¦¥

### â“Â¿QuÃ© es la carga perezosa?

La carga perezosa es una estrategia de recuperaciÃ³n de datos utilizada por JPA (Java Persistence API) para optimizar el rendimiento de las consultas a la base de datos.

<aside> ğŸ› 

Cuando se utiliza la carga perezosa, los datos de un atributo o relaciÃ³n no se recuperan de inmediato al cargar la entidad, sino que se obtienen solo cuando el atributo es accedido por el cÃ³digo.

</aside>

### âœ…Ventajas de la carga perezosa

1. <span style="color:rgb(0, 176, 80)"><b>Eficiencia</b></span>: Reduce la cantidad de datos cargados desde la base de datos, lo que disminuye el consumo de memoria y mejora el rendimiento general.
2.  <span style="color:rgb(0, 176, 80)"><b>Control de datos cargados</b></span>: Permite cargar solo los datos estrictamente necesarios en cada momento.
3. <span style="color:rgb(0, 176, 80)"><b>Aptitud para relaciones complejas</b></span>: En relaciones uno a muchos o muchos a muchos, evita cargar listas o colecciones innecesarias.

### âš™ï¸ConfiguraciÃ³n

Para habilitar la carga perezosa, se utiliza la anotaciÃ³n `@Basic` con el atributo `fetch`:

```java
@Basic(fetch = FetchType.LAZY)
```

Esto tambiÃ©n es aplicable en asociaciones con `@OneToMany`, `@ManyToOne`, `@OneToOne`, y `@ManyToMany` mediante la configuraciÃ³n de `fetch = FetchType.LAZY`.

- Por defecto:
	- **Relaciones @OneToOne y @ManyToOne**: `FetchType.EAGER`.
	- **Relaciones @OneToMany y @ManyToMany**: `FetchType.LAZY`.
	- **Entidades**: `FetchType.EAGER`.

### Ejemplo de ImplementaciÃ³n

Entidad `Employee` con carga perezosa en un atributo grande:

```java
@Entity
public class Employee {

    @Id
    private Long id;

    @Column(name = "NAME")
    private String name;

    @Basic(fetch = FetchType.LAZY)
    @Lob
    @Column(name = "COMMENTS")
    private String comments;

    // Getters y setters
}
```

### ğŸ™‹ğŸ½â€â™‚ï¸Caso de Uso:

4. Si se accede solo al nombre, el campo `comments` no se cargarÃ¡.
5. Cuando se acceda al atributo `comments`, se realizarÃ¡ una consulta adicional a la base de datos para cargar su contenido.

```java
Employee emp = entityManager.find(Employee.class, 1L);
System.out.println(emp.getName()); // Solo se carga el nombre.
System.out.println(emp.getComments()); // En este momento, se realiza la consulta adicional.
```

### ğŸ¤”Consideraciones importantes

> **Carga ansiosa (EAGER)**: Aunque puede ser conveniente para simplificar el acceso a datos, puede causar problemas de rendimiento al cargar datos innecesarios.
>
> **LazyInitializationException**: Al trabajar con carga perezosa en entornos fuera de un contexto de persistencia (como vistas web), asegÃºrate de inicializar los datos antes de cerrar la sesiÃ³n de Hibernate.

---

# **7. Objetos Grandes (LOBs)**

### ğŸ¾Â¿QuÃ© son los LOBs?

<aside> ğŸ’¡

En JPA, los **LOBs** (Large Objects) son campos utilizados para almacenar grandes cantidades de datos binarios o de texto. Estos datos pueden ser:

</aside>

- **CLOB** (Character Large Object): DiseÃ±ado para almacenar grandes cantidades de texto.
- **BLOB** (Binary Large Object): DiseÃ±ado para almacenar datos binarios, como imÃ¡genes o videos.

### ğŸª›ConfiguraciÃ³n de @Lob

La anotaciÃ³n `@Lob` se utiliza para marcar un atributo como LOB en JPA. Dependiendo del tipo de dato Java, se mapearÃ¡ automÃ¡ticamente como CLOB o BLOB:

- **CLOB**: Usado para `String`, `char[]`, `Character[]`.
- **BLOB**: Usado para `byte[]`, `Byte[]`, o cualquier clase que implemente `Serializable`.

### Ejemplo con CLOB y BLOB

Entidad `Documento` con un archivo binario e informaciÃ³n textual:

```java
@Entity
public class Documento {

    @Id
    private Long id;

    @Lob
    private String contenido; // CLOB

    @Lob
    private byte[] archivo; // BLOB

    // Getters y setters
}
```

### ğŸ¤“Uso de LOBs con carga perezosa

Cuando los LOBs son datos grandes que no siempre se necesitan, combÃ­nalos con `FetchType.LAZY`:

```java
@Basic(fetch = FetchType.LAZY)
@Lob
private byte[] archivo;
```

### âœ…Ventajas y desventajasâŒ

- **Ventajas**:
    - Capacidad para almacenar datos muy grandes.
    - IntegraciÃ³n directa con bases de datos modernas.
- **Desventajas**:
    - Impacto en el rendimiento si no se configuran correctamente (por ejemplo, sin carga perezosa).

### ğŸ—’ï¸Nota:

> **Consejo**:Â **Los LOB son Ãºtiles para almacenar datos grandes, pero no se deben abusar de ellos**.Â **Los LOB pueden ser ineficientes para recuperar y almacenar**.Â **Siempre que sea posible, se deben evitar los LOB**.Â **Si se necesita almacenar datos grandes, se debe considerar el uso de un sistema de archivos o un sistema de almacenamiento de objetos**.

---

# **8. Tipos Enumerados (enum): @EnumeratedğŸ”¢**

```java
public enum EmployeeType {
    FULL_TIME_EMPLOYEE, // ordinal 0
    PART_TIME_EMPLOYEE, // ordinal 1
    CONTRACT_EMPLOYEE   // ordinal 2
}
```

## 8.1 Mapeo Ordinal de Enumerados

Los valores de un tipo enumerado en Java tienen unaÂ **asignaciÃ³n ordinal**Â implÃ­cita que seÂ **determina por el orden en que se declararon**.

<aside style="border: 2px solid yellow; padding: 10px; border-radius: 5px;"> 
ğŸ’¡ElÂ <b>ordinal se usa de modo predeterminado para representar y almacenar los valores del tipo enumerado en la base de datos</b>.
</aside>

El proveedor asumirÃ¡ que laÂ **columna de la base de datos es de tipo entero**.

### â³Ejemplo de Enumerado y Entidad con Mapeo Ordinal

```java
@Entity
public class Employee {
    @Id
    private long id;

    @Enumerated(EnumType.ORDINAL) // Mapeo ordinal
    private EmployeeType type;
    // ...
}
```

### â˜¢ï¸Problemas con el Mapeo Ordinal

<aside style="border: 2px solid red; padding: 10px; border-radius: 5px;"> 
ğŸš¨ Si se introduce un nuevo valor en medio del enumerado o se reorganizan las constantes, el mapeo ordinal puede provocar inconsistencias en los datos ya almacenados. Por ejemplo, agregar <b>PART_TIME_BENEFITS_EMPLOYEE</b> despuÃ©s de <b>PART_TIME_EMPLOYEE</b> cambiarÃ­a los valores ordinales de los elementos siguientes, causando errores en los registros existentes.
</aside>

## 8.2 Mapeo de Enumerados como Cadenas

Para evitar los problemas asociados al mapeo ordinal, se puede utilizar la anotaciÃ³n `@Enumerated` con el valor `EnumType.STRING`. Esto almacena los nombres de las constantes en la base de datos como cadenas, lo que hace que el mapeo sea mÃ¡s robusto frente a cambios en el enumerado.

### Ejemplo de Mapeo de Enumerado como Cadena

```java
@Entity
public class Employee {
    @Id
    private long id;

    @Enumerated(EnumType.STRING) // Mapeo como cadena
    private EmployeeType type;
    // ...
}
```

### ğŸ™‹ğŸ½â€â™‚ï¸Ventajas y Desventajas del Mapeo como Cadena

- âœ… **Ventajas:**
    - Evita problemas de consistencia al modificar el orden de las constantes o al agregar nuevas.
    - Hace que los datos en la base de datos sean mÃ¡s legibles.
- âŒ **Desventajas:**
    - Requiere mÃ¡s espacio de almacenamiento que el mapeo ordinal.
    - Es mÃ¡s sensible a cambios en los nombres de las constantes.

## 8.3 Uso de MÃ©todos @PostLoad y @PrePersist

<aside style="border: 2px solid blue; padding: 10px; border-radius: 5px;"> 
ğŸ¤“Para obtener un mayor control sobre cÃ³mo se mapean y persisten los valores enumerados, se pueden emplear los mÃ©todos de ciclo de vida <b>@PostLoad</b> y <b>@PrePersist</b>.
</aside>

- <span style="color:rgb(0, 176, 80)"><b>@PostLoad</b></span>: se invoca despuÃ©s de que se cargue una entidad de la base de datos.Â [PostLoad](https://jakarta.ee/specifications/persistence/3.1/apidocs/jakarta.persistence/jakarta/persistence/PostLoad).
- <span style="color:rgb(0, 176, 80)"><b>@PrePersist</b></span>: se invoca antes de que se persista una entidad en la base de datos.Â [PrePersist](https://jakarta.ee/specifications/persistence/3.1/apidocs/jakarta.persistence/jakarta/persistence/PrePersist).

### Ejemplo de Uso con Atributos Transitorios

En este ejemplo, un enumerado `Prioridad` utiliza un valor entero para representar su estado, mientras que el cÃ³digo de negocio trabaja con la instancia del enumerado.

```java
public enum Prioridad {
    BAJA(100), MEDIA(200), ALTA(300);

    private int valor;

    private Prioridad(int valor) {
        this.valor = valor;
    }

    public int getValor() {
        return valor;
    }

    public static Prioridad of(int valor) {
	    if (codigo!=null||!codigo.equalsIgnoreCase(" ")){
	            for (Prioridad p: Prioridad.values()){
	                if (p.getValor().equalsIgnoreCase(valor)) return c;
	            }
	        }
	    return null;
	 }
}

@Entity
public class Articulo {
    @Id
    private long id;

    @Basic
    private int valorPrioridad; // Mapeado en la base de datos

    @Transient
    private Prioridad prioridad; // Usado en el negocio

    @PostLoad
    private void cargarPrioridad() {
        this.prioridad = Prioridad.of(valorPrioridad);
    }

    @PrePersist
    private void persistirPrioridad() {
        this.valorPrioridad = prioridad.getValor();
    }
}
```

## 8.4 Uso de Conversores Personalizados con @Converter

>Desde JPA 2.1, es posible definir conversores personalizados implementando la interfaz `AttributeConverter`. Esto proporciona una soluciÃ³n flexible y reutilizable para mapear enumerados.

### ğŸ›ImplementaciÃ³n de un Conversor Personalizado

```java
public enum Categoria {
    DEPORTE("D"), MUSICA("M"), TECNOLOGIA("T");

    private String codigo;

    private Categoria(String codigo) {
        this.codigo = codigo;
    }

    public String getCodigo() {
        return codigo;
    }

    public static Categoria fromCodigo(String codigo) {
	    if (codigo!=null||!codigo.equalsIgnoreCase(" ")){
	            for (Categoria c: Categoria.values()){
	                if (c.getCodigo().equalsIgnoreCase(codigo)) return c;
	            }
	        }
	     return null;
    }
}

@Converter(autoApply = true) //No es una buena prÃ¡ctica
public class CategoriaConverter implements AttributeConverter<Categoria, String> {

    @Override
    public String convertToDatabaseColumn(Categoria categoria) {
        return (categoria != null) ? categoria.getCodigo() : null;
    }

    @Override
    public Categoria convertToEntityAttribute(String codigo) {
        return (codigo != null) ? Categoria.fromCodigo(codigo) : null;
    }
}

@Entity
public class Articulo {

// ...

    @Convert(converter = ConvertidorCategoria.class) //Forma correcta de registrar adaptador
    private Categoria categoria;
}
```

> El uso de `autoApply = true` permite aplicar automÃ¡ticamente este conversor a todos los atributos del tipo `Categoria`. (No es una buena prÃ¡ctica)

### âœ…Ventajas del Uso de Conversores

- Permite manejar enumerados con estructuras complejas o datos adicionales.
- Proporciona una mayor flexibilidad y control sobre el mapeo.
- Facilita la integraciÃ³n de enumerados en aplicaciones con reglas de negocio especÃ­ficas.

## 8.5 Uso de Enumerados en JPQL

Los enumerados pueden utilizarse directamente en consultas JPQL. En este caso, es posible emplear el valor completo del enumerado o parÃ¡metros con nombre para mayor flexibilidad.

### Ejemplo de Consulta JPQL con Enumerados

```java
// Consulta estÃ¡tica
String jpql = "SELECT a FROM Articulo a WHERE a.categoria = com.example.Categoria.DEPORTE";
List<Articulo> articulos = em.createQuery(jpql, Articulo.class).getResultList();

// Consulta dinÃ¡mica
String jpql = "SELECT a FROM Articulo a WHERE a.categoria = :categoria";
TypedQuery<Articulo> query = em.createQuery(jpql, Articulo.class);
query.setParameter("categoria", Categoria.TECNOLOGIA);
List<Articulo> articulos = query.getResultList();
```

Usar parÃ¡metros con nombre es preferible, ya que mejora la legibilidad y evita dependencias de nombres de clases y constantes.

### ğŸ§®ConclusiÃ³n

| **Caso de Uso**                                                                 | **Tipo de Mapeo**                                          | **JustificaciÃ³n**                                                                                                                                                                                                               |
| ------------------------------------------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Enumerados simples con pocos valores que no cambiarÃ¡n en el tiempo**          | `@Enumerated(EnumType.ORDINAL)`                            | Uso eficiente de almacenamiento (ocupa menos espacio al usar nÃºmeros). Ãštil si el orden y los valores del enumerado no cambiarÃ¡n jamÃ¡s.                                                                                         |
| **Enumerados con posibles modificaciones en el orden o la cantidad de valores** | `@Enumerated(EnumType.STRING)`                             | Evita problemas de consistencia al modificar el orden o agregar nuevos valores. AdemÃ¡s, mejora la legibilidad en la base de datos al almacenar cadenas en lugar de nÃºmeros.                                                     |
| **Enumerados con valores complejos o datos adicionales**                        | **Con especÃ­fica o estructuras complejas. Permite personalizar completamente cÃ³mo se almacenan y recuperan los valores.                                         |
| **Enumerados con valores transitorios o calculados**                            | **MÃ©todos `@PostLoad` y `@PrePersist`**                    | Ãštil cuando se necesita transformar un valor intermedio (como un nÃºmero o una cadena) a un objeto enumerado antes de usarlo, o viceversa, para desacoplar la lÃ³gica interna del modelo y el almacenamiento en la base de datos. |
| **Consultas JPQL que incluyen enumerados**                                      | **Dependiendo del caso: `EnumType.STRING` o `@Converter`** | Si las consultas JPQL se basan en enumerados, el mapeo como cadena (`EnumType.STRING`) es preferible para evitar problemas de compatibilidad. Los conversores tambiÃ©n son Ãºtiles si el enumerado incluye lÃ³gica personalizada.  |

# **9. Tipos Temporales: `@Temporal` ğŸ•’**

<aside  style="border: 2px solid purple; padding: 10px; border-radius: 5px;"> 
ğŸ’¡Los <b>tipos temporales</b>  en JPA son utilizados para trabajar con atributos basados en fechas y tiempos.
</aside>

---

### ğŸ—‚ **Tipos Temporales Admitidos**

| **CategorÃ­a**          | **Clases Admitidas**                                   |
| ---------------------- | ------------------------------------------------------ |
| **Java SQL**           | `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp` |
| **Java Util**          | `java.util.Date`, `java.util.Calendar`                 |
| **Java Time (Java 8)** | `java.time` API                                        |

---

### ğŸ”§ **Uso de `@Temporal`**

>- La anotaciÃ³n `@Temporal` es necesaria para especificar cÃ³mo mapear las fechas y tiempos en los tipos de **Java Util** (`Date` y `Calendar`) hacia **tipos JDBC**.

---

### ğŸŒŸ **Valores de TemporalType**

`@Temporal` usa la enumeraciÃ³n `TemporalType` para especificar el mapeo:

| **Valor**       | **DescripciÃ³n**                                      |
| --------------- | ---------------------------------------------------- |
| **`DATE`**      | Mapea solo la **fecha** (sin tiempo).                |
| **`TIME`**      | Mapea solo la **hora** (sin fecha).                  |
| **`TIMESTAMP`** | Mapea fecha y hora (similar a `java.sql.Timestamp`). |

---

### ğŸ“˜ **Ejemplo de Uso**

```java
@Entity
public class Employee {
    @Id
    private long id;

    @Temporal(TemporalType.DATE) // Solo almacena la fecha
    private Calendar dob;

    @Temporal(TemporalType.DATE) // TambiÃ©n almacena fecha
    @Column(name="S_DATE")
    private Date startDate;

    // ...
}
```

> Nota ğŸ“: En este ejemplo:
> 
> - `dob` almacena la fecha de nacimiento.
> - `startDate` almacena la fecha de inicio con un nombre de columna personalizado.

---

### ğŸš¨ **DeprecaciÃ³n en JPA 3.2 y Superior**

La anotaciÃ³n `@Temporal` estÃ¡ **desaprobada** a partir de **JPA 3.2**.

Se recomienda usar los tipos de **Java Time API** (`java.time.LocalDate`, `java.time.LocalDateTime`, etc.) para trabajar con fechas.

Si es necesario, usa `@Convert` con un conversor de atributos.

---

### ğŸ¯ **Resumen Visual: ElecciÃ³n de Tipos Temporales**

```java
java.util.Date â†”  @Temporal
java.util.Calendar â†”  @Temporal
java.time (Java 8 y superior) â†” SIN @Temporal
```

---

# **10. Atributos Transitorios: `@Transient` ğŸš«**

<aside> ğŸ’¡

Los atributos transitorios son aquellos **que no deben persistir en la base de datos**. Son Ãºtiles para almacenar informaciÃ³n temporal o de cÃ¡lculo.

</aside>

---

### ğŸ¯ **CÃ³mo Hacer un Campo Transitorio**

6. Usa el **modificador `transient`** de Java.
    - No persiste en la base de datos **ni durante la serializaciÃ³n**.
7. Usa la **anotaciÃ³n `@Transient`**.
    - **Se conserva durante la serializaciÃ³n**, pero **no se guarda en la base de datos**.

---

### ğŸ›  **Razones para Usar Campos Transitorios**

- **Evitar persistencia duplicada:** Cuando mezclamos accesos por campos y getters.
- **Almacenamiento temporal:** Para guardar estados calculados o datos en cachÃ©.
- **SeparaciÃ³n de lÃ³gica:** Manejar valores dependientes del entorno (como el idioma).

---

### ğŸ“˜ **Ejemplo de Campo Transitorio**

```java
@Entity
public class Employee {
    @Id
    private long id;

    private String name;
		@Transient              //No persiste solo en BD
    private long salary;

    transient private String translatedName; // No persistente ni en BD ni en serializacion

    public String toString() {
        if (translatedName == null) {
            translatedName = ResourceBundle.getBundle("EmpResources").getString("Employee");
        }
        return translatedName + ": " + id + " " + name;
    }
}
```

---

### ğŸ”‘ **Diferencia entre `transient` y `@Transient`**

|**Modificador/AnotaciÃ³n**|**Persistente**|**Serializable**|**Uso ComÃºn**|
|---|---|---|---|
|`transient` (Java)|âŒ|âŒ|Para datos temporales en memoria.|
|`@Transient` (JPA)|âŒ|âœ…|Para datos que no deben guardarse en la base de datos.|

---

# 10. **Mapeo de Clave Primaria: @Id**

ğŸ“Œ **DefiniciÃ³n**

- Toda entidad debe tener una clave primaria asignada a una tabla.
- La anotaciÃ³n `@Id` indica el identificador de la entidad.

> ğŸ’¡ **Nota:** Si el identificador estÃ¡ compuesto por un Ãºnico atributo, se denomina **identificador simple**.

---

## 10.1 **Sobrescritura de la Clave Primaria**

âš™ï¸ **Uso de @Column**

- Se puede sobrescribir el nombre de la columna con la anotaciÃ³n `@Column`.
- Restricciones:
    - Claves primarias **no nulas** y **no actualizables**.
    - Si varios campos usan la misma columna, define `insertable=false`.

---

## 10.2 **Tipos de Claves Primarias Admitidos**

ğŸ“Š **Tabla de Tipos Permitidos**

|CategorÃ­a|Ejemplos|
|---|---|
|**Primitivos**|`byte`, `int`, `short`, `long`, `char`|
|**Clases Envolventes**|`Byte`, `Integer`, `Short`, `Long`, `Character`|
|**Texto**|`java.lang.String`|
|**NumÃ©ricos Grandes**|`java.math.BigInteger`, `java.math.BigDecimal`|
|**Tipos Temporales**|`java.util.Date`, `java.sql.Date`, `java.util.Calendar`, `java.time.LocalDate`, etc.|

>âš ï¸ **Advertencia:**
>
>- Evitar `float` y `double` debido a problemas de precisiÃ³n y confiabilidad.

---

## 10.3 **GeneraciÃ³n de Claves Primarias: @GeneratedValue**

#### ğŸ¯ DefiniciÃ³n

- `@GeneratedValue` permite que el proveedor de persistencia genere automÃ¡ticamente los identificadores.
- Estrategias disponibles:

|**Estrategia**|**DescripciÃ³n**|
|---|---|
|`AUTO`|Estrategia predeterminada, seleccionada por el proveedor.|
|`IDENTITY`|Usa una columna de identidad de la base de datos.|
|`SEQUENCE`|Usa una secuencia de base de datos.|
|`TABLE`|Usa una tabla para garantizar unicidad en los IDs.|
|`UUID`|Genera un identificador Ãºnico universal basado en `java.util.UUID`.|

#### Ejemplo bÃ¡sico:

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private long id;
```

---

#### Diagrama Visual de Estrategias

```mermaid

graph TD;
    A[@GENERATEDVALUE] --> B[AUTO]
    B -->|Elige estrategia segÃºn la base de datos| B1
    B -->|Ejemplo: prototipos/desarrollo| B2
    
    A --> C[IDENTITY]
    C -->|Utiliza una columna de identidad de base de datos| C1
    C -->|No se puede compartir entre entidades| C2
    C -->|ID no disponible hasta la inserciÃ³n| C3
    
    A --> D[SEQUENCE]
    D -->|Utiliza una secuencia de base de datos| D1
    D -->|Altamente eficiente y adaptable| D2
    D -->|Permite compartir entre entidades| D3
    D -->|AsignaciÃ³n en bloques para mejorar rendimiento| D4
    
    A --> E[TABLE]
    E -->|Utiliza una tabla para almacenar identificadores| E1
    E -->|Alta portabilidad entre bases de datos| E2
    E -->|Admite mÃºltiples generadores en una tabla| E3
    E -->|Define generadores con @TableGenerator| E4

    A --> F[UUID]
    F -->|Genera identificadores Ãºnicos universales| F1
    F -->|Atributo debe ser de tipo java.util.UUID| F2
```

---

### 10.3.1 **GeneraciÃ³n AutomÃ¡tica: `GenerationType.AUTO`**

#### ğŸ“Œ **CaracterÃ­sticas**

- Estrategia flexible para desarrollo/prototipos.
- Ejemplo:

```java
@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private long id;
}
```

---

### 10.3.2 **GeneraciÃ³n con Tablas: `GenerationType.TABLE`**

#### ğŸ“Š Esquema de Tabla

|**Columna**|**DescripciÃ³n**|
|---|---|
|`GEN_NAME`|Identifica el generador especÃ­fico|
|`GEN_VALUE`|Almacena el Ãºltimo valor asignado|

#### Ejemplo:

```sql
CREATE TABLE ID_GEN (
    GEN_NAME VARCHAR(80),
    GEN_VALUE INTEGER,
    PRIMARY KEY (GEN_NAME)
);
```

#### ğŸ“‹ CÃ³digo Ejemplo

```java
@TableGenerator(name = "Emp_Gen", table = "ID_GEN", pkColumnName = "GEN_NAME", valueColumnName = "GEN_VALUE")
@Id
@GeneratedValue(strategy = GenerationType.TABLE, generator = "Emp_Gen")
private long id;
```

---

### 10.3.3 **GeneraciÃ³n con Secuencia: `GenerationType.SEQUENCE`**

#### ğŸ”— Ventajas de las Secuencias

- Eficientes y rÃ¡pidas.
- Pueden asignar bloques de IDs para minimizar consultas a la base de datos.

#### ğŸ“‹ Ejemplo de CÃ³digo

```java
@SequenceGenerator(name = "Emp_Gen", sequenceName = "Emp_Seq")
@Id
@GeneratedValue(generator = "Emp_Gen")
private long id;
```

#### ğŸ“œ DefiniciÃ³n SQL de la Secuencia

```sql
CREATE SEQUENCE Emp_Seq
 MINVALUE 1
 START WITH 1
 INCREMENT BY 50;
```

---

### 10.3.4 **GeneraciÃ³n con Identidad: `GenerationType.IDENTITY`**

#### ğŸ” CaracterÃ­sticas

- Usa columnas autonumÃ©ricas como claves primarias.
- El ID no estÃ¡ disponible hasta que se realiza la inserciÃ³n.

#### ğŸ“‹ Ejemplo de Uso

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private long id;
```

---

### 10.3.5 **GeneraciÃ³n con UUID: `GenerationType.UUID`**

#### ğŸ”‘ DefiniciÃ³n

- Genera un identificador Ãºnico universal (UUID).
- Tipo de atributo requerido: `java.util.UUID`.

#### ğŸ“‹ Ejemplo de CÃ³digo

```java
@Id
@GeneratedValue(strategy = GenerationType.UUID)
private UUID id;
```