# 1. Paginaci√≥n de Consultas

 <aside style="border: 2px solid purple; padding: 10px; border-radius: 5px;"> 
Las grandes cantidades de resultados de consultas suelen ser un problema para muchas aplicaciones. Al mostrar el conjunto completo de resultados, ya sea porque son muchos o porque el medio (por ejemplo, una aplicaci√≥n web) hace que mostrar numerosas filas sea ineficiente, se requiere poder mostrar <b>rangos</b> de resultados y ofrecer a los usuarios la posibilidad de controlar qu√© segmento de datos est√°n visualizando.
</aside>

---

## üìñ Conceptos Clave: Paginaci√≥n

### ¬øQu√© es la paginaci√≥n?

La t√©cnica de paginaci√≥n consiste en presentar al usuario una **tabla de tama√±o fijo** que act√∫a como una ventana deslizante sobre el conjunto de resultados. Cada incremento de resultados se denomina **p√°gina** y el proceso de navegar entre ellas se conoce como **paginaci√≥n**.

- **Ventajas de la paginaci√≥n:**
    - Evita la sobrecarga al mostrar demasiados resultados de una sola vez.
    - Mejora la experiencia del usuario al permitirle navegar por segmentos espec√≠ficos.
    - Optimiza el rendimiento de la aplicaci√≥n y la base de datos.

### Evoluci√≥n y desaf√≠os

- **Desaf√≠os iniciales:**  
    Antes de que existiera soporte a nivel de base de datos, una t√©cnica com√∫n era:
    
    1. Recuperar todas las claves primarias del conjunto de resultados.
    2. Emitir consultas separadas para obtener los resultados completos utilizando rangos de valores de clave primaria.
- **N√∫mero de fila l√≥gica:**  
    Los proveedores de bases de datos introdujeron el concepto de _n√∫mero de fila l√≥gica_ en los resultados de consultas, permitiendo:
    
    - Utilizar la posici√≥n de fila para recuperar porciones espec√≠ficas (por ejemplo:
        
        ```sql
        SELECT * FROM posts OFFSET 10 LIMIT 10
		```).
		```
        
- **Conjuntos de resultados desplazables en JDBC:**  
    La especificaci√≥n JDBC implement√≥ conjuntos de resultados desplazables, permitiendo navegar hacia adelante y hacia atr√°s de forma din√°mica.

### F√≥rmula de paginaci√≥n

La f√≥rmula para calcular la posici√≥n de inicio (OFFSET) es:

	OFFSET=(LIMIT√ópage(N))‚àíLIMIT

O en c√≥digo Java:

```sql
int primerResultado = (numeroPagina - 1) * tama√±oPagina;
```
---
## üìå M√©todos de Paginaci√≥n en JPA

Las interfaces **Query** y **TypedQuery** proporcionan soporte para la paginaci√≥n a trav√©s de dos m√©todos fundamentales:

- **setFirstResult(int startPosition):**  
    Establece el primer resultado que se desea recuperar (numerado desde cero).
    
- **setMaxResults(int maxResult):**  
    Define el n√∫mero m√°ximo de resultados a devolver desde el punto especificado.

> **Nota:**  
> Los valores establecidos para estos m√©todos tambi√©n se pueden recuperar mediante `getFirstResult()` y `getMaxResults()`.  
> **Importante:** No se deben usar estos m√©todos con consultas que hagan joins sobre relaciones de colecci√≥n (uno a muchos, muchos a muchos) ya que podr√≠an devolver resultados duplicados y, por lo tanto, afectar la l√≥gica de paginaci√≥n.


---

## üîç Ejemplo Pr√°ctico: Paginador de Resultados

A continuaci√≥n se muestra un ejemplo de c√≥mo implementar la paginaci√≥n utilizando un bean de sesi√≥n con estado en JPA.

### Descripci√≥n del Ejemplo

- **Objetivo:**  
    Proveer una plantilla general para un bean que mantenga el estado intermedio de una consulta y que permita procesar los resultados en segmentos (p√°ginas).
    
- **Funcionamiento:**
    
    1. Se inicializa el paginador con el tama√±o de p√°gina, el nombre de una consulta de recuento (para determinar el total de resultados) y el nombre de una consulta para generar el informe.
    2. Al solicitar resultados, se calcula el primer resultado mediante la f√≥rmula de paginaci√≥n y se utilizan `setFirstResult()` y `setMaxResults()` para obtener la porci√≥n deseada.
    3. Se proveen m√©todos `next()`, `previous()` y `getResultadosActuales()` para navegar entre p√°ginas.
    4. Se utiliza un bean de sesi√≥n con estado (`@Stateful`), lo que permite integrarlo directamente en aplicaciones web (por ejemplo, Jakarta Server Pages o Jakarta Server Faces).

### C√≥digo del Ejemplo

```java
@Stateful
public class PaginadorDeResultados {
    @PersistenceContext(unitName="QueryPaging")
    private EntityManager em;
    
    // Nombre de la consulta para generar el informe
    private String nombreConsultaInforme;
    
    // P√°gina actual y total de resultados
    private long paginaActual;
    private long totalResultados;
    
    // Tama√±o de cada p√°gina (n√∫mero de resultados por p√°gina)
    private long tama√±oPagina;

    // Getters para tama√±o de p√°gina y total de p√°ginas
    public long getTama√±oPagina() {
        return tama√±oPagina;
    }

    public long getTotalPaginas() {
        return totalResultados / tama√±oPagina;
    }

    /**
     * Inicializa el paginador.
     * @param tama√±oPagina Tama√±o de cada p√°gina
     * @param nombreConsultaRecuento Nombre de la consulta para contar resultados
     * @param nombreConsultaInforme Nombre de la consulta para generar el informe
     */
    public void init(long tama√±oPagina, String nombreConsultaRecuento, String nombreConsultaInforme) {
        this.tama√±oPagina = tama√±oPagina;
        this.nombreConsultaInforme = nombreConsultaInforme;
        // Ejecuta la consulta de recuento para obtener el total de resultados
        totalResultados = em.createNamedQuery(nombreConsultaRecuento, Long.class).getSingleResult();
        paginaActual = 0;
    }

    /**
     * Recupera los resultados de la p√°gina actual.
     * @return Lista de resultados para la p√°gina actual.
     */
    public List getResultadosActuales() {
        return em.createNamedQuery(nombreConsultaInforme)
                 .setFirstResult((int) (paginaActual * tama√±oPagina))
                 .setMaxResults((int) tama√±oPagina)
                 .getResultList();
    }

    /**
     * Navega a la siguiente p√°gina.
     */
    public void next() {
        paginaActual++;
    }

    /**
     * Navega a la p√°gina anterior.
     */
    public void previous() {
        paginaActual--;
        if (paginaActual < 0) {
            paginaActual = 0;
        }
    }

    // Getters y setters para la p√°gina actual
    public long getPaginaActual() {
        return paginaActual;
    }

    public void setPaginaActual(long paginaActual) {
        this.paginaActual = paginaActual;
    }

    /**
     * M√©todo de limpieza del bean de sesi√≥n.
     */
    @Remove
    public void finished() {}
}

```
---
## üìä Tabla Resumen: M√©todos de Paginaci√≥n

|M√©todo|Descripci√≥n|Ejemplo de Uso|
|---|---|---|
|`setFirstResult(int startPosition)`|Define el primer resultado a recuperar (numeraci√≥n desde 0).|`.setFirstResult(primerResultado)`|
|`setMaxResults(int maxResult)`|Establece el n√∫mero m√°ximo de resultados a devolver.|`.setMaxResults(tama√±oPagina)`|
|`getFirstResult()`|Recupera la posici√≥n del primer resultado (0 por defecto si no se ha establecido).||
|`getMaxResults()`|Recupera el n√∫mero m√°ximo de resultados configurado.||

---

## üó∫Ô∏è Diagrama de Flujo: Proceso de Paginaci√≥n

![[Pasted image 20250220092740.png]]

---

## üìå Consideraciones Importantes

- **Uso en consultas con relaciones multivaluadas:**  
    Los m√©todos `setFirstResult()` y `setMaxResults()` **no deben usarse** en consultas que realizan uniones sobre relaciones de colecci√≥n (como uno a muchos o muchos a muchos) porque pueden generar resultados duplicados, lo que dificulta la paginaci√≥n basada en la posici√≥n l√≥gica de los resultados.
    
- **Soporte del proveedor de persistencia:**  
    Cada proveedor de persistencia (como Hibernate) puede implementar el soporte de paginaci√≥n de manera distinta. Es recomendable familiarizarse con el nivel de soporte en la base de datos objetivo.
    
- **Aplicaci√≥n pr√°ctica:**  
    Este enfoque se puede vincular directamente a sesiones HTTP en aplicaciones web, utilizando frameworks como Jakarta Server Faces (JSF) para presentar los resultados en tablas de datos.
]]